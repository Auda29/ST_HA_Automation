{"version":3,"file":"ha-websocket-DcUbagYv.js","sources":["../../../frontend/node_modules/home-assistant-js-websocket/dist/messages.js","../../../frontend/node_modules/home-assistant-js-websocket/dist/util.js","../../../frontend/node_modules/home-assistant-js-websocket/dist/store.js","../../../frontend/node_modules/home-assistant-js-websocket/dist/collection.js","../../../frontend/node_modules/home-assistant-js-websocket/dist/commands.js","../../../frontend/node_modules/home-assistant-js-websocket/dist/entities.js"],"sourcesContent":["export function auth(accessToken) {\n    return {\n        type: \"auth\",\n        access_token: accessToken,\n    };\n}\nexport function supportedFeatures() {\n    return {\n        type: \"supported_features\",\n        id: 1, // Always the first message after auth\n        features: { coalesce_messages: 1 },\n    };\n}\nexport function states() {\n    return {\n        type: \"get_states\",\n    };\n}\nexport function config() {\n    return {\n        type: \"get_config\",\n    };\n}\nexport function services() {\n    return {\n        type: \"get_services\",\n    };\n}\nexport function user() {\n    return {\n        type: \"auth/current_user\",\n    };\n}\nexport function callService(domain, service, serviceData, target, returnResponse) {\n    const message = {\n        type: \"call_service\",\n        domain,\n        service,\n        target,\n        return_response: returnResponse,\n    };\n    if (serviceData) {\n        message.service_data = serviceData;\n    }\n    return message;\n}\nexport function subscribeEvents(eventType) {\n    const message = {\n        type: \"subscribe_events\",\n    };\n    if (eventType) {\n        message.event_type = eventType;\n    }\n    return message;\n}\nexport function unsubscribeEvents(subscription) {\n    return {\n        type: \"unsubscribe_events\",\n        subscription,\n    };\n}\nexport function ping() {\n    return {\n        type: \"ping\",\n    };\n}\nexport function error(code, message) {\n    return {\n        type: \"result\",\n        success: false,\n        error: {\n            code,\n            message,\n        },\n    };\n}\n","export function parseQuery(queryString) {\n    const query = {};\n    const items = queryString.split(\"&\");\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i].split(\"=\");\n        const key = decodeURIComponent(item[0]);\n        const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n        query[key] = value;\n    }\n    return query;\n}\n// From: https://davidwalsh.name/javascript-debounce-function\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// eslint-disable-next-line: ban-types\nexport const debounce = (func, wait, immediate = false) => {\n    let timeout;\n    // @ts-ignore\n    return function (...args) {\n        // @ts-ignore\n        const context = this;\n        const later = () => {\n            timeout = undefined;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n};\nexport const atLeastHaVersion = (version, major, minor, patch) => {\n    const [haMajor, haMinor, haPatch] = version.split(\".\", 3);\n    return (Number(haMajor) > major ||\n        (Number(haMajor) === major &&\n            (patch === undefined\n                ? Number(haMinor) >= minor\n                : Number(haMinor) > minor)) ||\n        (patch !== undefined &&\n            Number(haMajor) === major &&\n            Number(haMinor) === minor &&\n            Number(haPatch) >= patch));\n};\n","export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n","import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n","import * as messages from \"./messages.js\";\nexport const getStates = (connection) => connection.sendMessagePromise(messages.states());\nexport const getServices = (connection) => connection.sendMessagePromise(messages.services());\nexport const getConfig = (connection) => connection.sendMessagePromise(messages.config());\nexport const getUser = (connection) => connection.sendMessagePromise(messages.user());\nexport const callService = (connection, domain, service, serviceData, target, returnResponse) => connection.sendMessagePromise(messages.callService(domain, service, serviceData, target, returnResponse));\n","import { getCollection } from \"./collection.js\";\nimport { getStates } from \"./commands.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nfunction processEvent(store, updates) {\n    const state = Object.assign({}, store.state);\n    if (updates.a) {\n        for (const entityId in updates.a) {\n            const newState = updates.a[entityId];\n            let last_changed = new Date(newState.lc * 1000).toISOString();\n            state[entityId] = {\n                entity_id: entityId,\n                state: newState.s,\n                attributes: newState.a,\n                context: typeof newState.c === \"string\"\n                    ? { id: newState.c, parent_id: null, user_id: null }\n                    : newState.c,\n                last_changed: last_changed,\n                last_updated: newState.lu\n                    ? new Date(newState.lu * 1000).toISOString()\n                    : last_changed,\n            };\n        }\n    }\n    if (updates.r) {\n        for (const entityId of updates.r) {\n            delete state[entityId];\n        }\n    }\n    if (updates.c) {\n        for (const entityId in updates.c) {\n            let entityState = state[entityId];\n            if (!entityState) {\n                console.warn(\"Received state update for unknown entity\", entityId);\n                continue;\n            }\n            entityState = Object.assign({}, entityState);\n            const { \"+\": toAdd, \"-\": toRemove } = updates.c[entityId];\n            const attributesChanged = (toAdd === null || toAdd === void 0 ? void 0 : toAdd.a) || (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a);\n            const attributes = attributesChanged\n                ? Object.assign({}, entityState.attributes) : entityState.attributes;\n            if (toAdd) {\n                if (toAdd.s !== undefined) {\n                    entityState.state = toAdd.s;\n                }\n                if (toAdd.c) {\n                    if (typeof toAdd.c === \"string\") {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), { id: toAdd.c });\n                    }\n                    else {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), toAdd.c);\n                    }\n                }\n                if (toAdd.lc) {\n                    entityState.last_updated = entityState.last_changed = new Date(toAdd.lc * 1000).toISOString();\n                }\n                else if (toAdd.lu) {\n                    entityState.last_updated = new Date(toAdd.lu * 1000).toISOString();\n                }\n                if (toAdd.a) {\n                    Object.assign(attributes, toAdd.a);\n                }\n            }\n            if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a) {\n                for (const key of toRemove.a) {\n                    delete attributes[key];\n                }\n            }\n            if (attributesChanged) {\n                entityState.attributes = attributes;\n            }\n            state[entityId] = entityState;\n        }\n    }\n    store.setState(state, true);\n}\nconst subscribeUpdates = (conn, store) => conn.subscribeMessage((ev) => processEvent(store, ev), {\n    type: \"subscribe_entities\",\n});\nfunction legacyProcessEvent(store, event) {\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { entity_id, new_state } = event.data;\n    if (new_state) {\n        store.setState({ [new_state.entity_id]: new_state });\n    }\n    else {\n        const newEntities = Object.assign({}, state);\n        delete newEntities[entity_id];\n        store.setState(newEntities, true);\n    }\n}\nasync function legacyFetchEntities(conn) {\n    const states = await getStates(conn);\n    const entities = {};\n    for (let i = 0; i < states.length; i++) {\n        const state = states[i];\n        entities[state.entity_id] = state;\n    }\n    return entities;\n}\nconst legacySubscribeUpdates = (conn, store) => conn.subscribeEvents((ev) => legacyProcessEvent(store, ev), \"state_changed\");\nexport const entitiesColl = (conn) => atLeastHaVersion(conn.haVersion, 2022, 4, 0)\n    ? getCollection(conn, \"_ent\", undefined, subscribeUpdates)\n    : getCollection(conn, \"_ent\", legacyFetchEntities, legacySubscribeUpdates);\nexport const subscribeEntities = (conn, onChange) => entitiesColl(conn).subscribe(onChange);\n"],"names":["states","atLeastHaVersion","version","major","minor","patch","haMajor","haMinor","haPatch","createStore","state","listeners","unsubscribe","listener","out","i","setState","update","overwrite","currentListeners","action","apply","result","args","ret","UNSUB_GRACE_PERIOD","getCollection","conn","key","fetchCollection","subscribeUpdates","options","active","unsubProm","unsubTimer","store","refresh","refreshSwallow","err","setupUpdateSubscription","handleDisconnect","teardownUpdateSubscription","unsub","scheduleTeardownUpdateSubscription","subscriber","getStates","connection","messages.states","processEvent","updates","entityId","newState","last_changed","entityState","toAdd","toRemove","attributesChanged","attributes","ev","legacyProcessEvent","event","entity_id","new_state","newEntities","legacyFetchEntities","entities","legacySubscribeUpdates","entitiesColl","subscribeEntities","onChange"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}