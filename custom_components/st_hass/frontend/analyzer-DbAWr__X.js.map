{"version":3,"file":"analyzer-DbAWr__X.js","sources":["../../../frontend/src/analyzer/types.ts","../../../frontend/src/analyzer/ast-visitor.ts","../../../frontend/src/analyzer/trigger-generator.ts","../../../frontend/src/analyzer/dependency-analyzer.ts","../../../frontend/src/analyzer/helper-mapping.ts","../../../frontend/src/analyzer/storage-analyzer.ts"],"sourcesContent":["/**\r\n * Type definitions for the dependency analyzer\r\n *\r\n * This module defines the interfaces and types used throughout the analyzer\r\n * for analyzing Structured Text code and generating Home Assistant triggers.\r\n */\r\n\r\n/**\r\n * Represents a single Home Assistant automation trigger\r\n * Generated from analyzed input variables\r\n */\r\nexport interface TriggerConfig {\r\n  /** Trigger platform */\r\n  platform: \"state\" | \"numeric_state\" | \"event\" | \"time\";\r\n\r\n  /** Entity ID (e.g., 'sensor.temperature') */\r\n  entity_id?: string;\r\n\r\n  /** Optional: previous state to match */\r\n  from?: string | string[];\r\n\r\n  /** Optional: new state to match */\r\n  to?: string | string[];\r\n\r\n  /** Optional: states to exclude from triggering (from) */\r\n  not_from?: string[];\r\n\r\n  /** Optional: states to exclude from triggering (to) */\r\n  not_to?: string[];\r\n\r\n  /** Optional: trigger on attribute change */\r\n  attribute?: string;\r\n\r\n  /** Optional: duration constraint (e.g., '00:05:00') */\r\n  for?: string;\r\n\r\n  /** Optional: for numeric_state - trigger above this value */\r\n  above?: number;\r\n\r\n  /** Optional: for numeric_state - trigger below this value */\r\n  below?: number;\r\n\r\n  /** Optional: edge detection ('rising', 'falling') */\r\n  edge?: \"rising\" | \"falling\";\r\n\r\n  /** Optional: unique identifier for the trigger */\r\n  id?: string;\r\n\r\n  /** Optional: event type for event triggers */\r\n  event_type?: string;\r\n\r\n  /** Optional: event data filter for event triggers */\r\n  event_data?: Record<string, unknown>;\r\n\r\n  /** Optional: time for time-based triggers (e.g., '07:00:00') */\r\n  at?: string;\r\n}\r\n\r\n/**\r\n * Edge trigger detection result\r\n * Identifies rising/falling edge patterns in the code\r\n */\r\nexport interface EdgeTrigger extends TriggerConfig {\r\n  platform: \"state\";\r\n  from: string;\r\n  to: string;\r\n  edge: \"rising\" | \"falling\";\r\n}\r\n\r\n/**\r\n * Represents a dependency on a Home Assistant entity\r\n * Extracted from variable bindings in the code\r\n */\r\nexport interface EntityDependency {\r\n  /** Variable name in ST code */\r\n  variableName: string;\r\n\r\n  /** Entity ID bound to this variable */\r\n  entityId?: string;\r\n\r\n  /** Direction: INPUT (%I*), OUTPUT (%Q*), or MEMORY (%M*) */\r\n  direction: \"INPUT\" | \"OUTPUT\" | \"MEMORY\";\r\n\r\n  /** Data type of the variable */\r\n  dataType: string;\r\n\r\n  /** Whether this variable should trigger automation */\r\n  isTrigger: boolean;\r\n\r\n  /** Location in source code */\r\n  location?: { line: number; column: number };\r\n}\r\n\r\n/**\r\n * Complete analysis result\r\n */\r\nexport interface AnalysisResult {\r\n  triggers: TriggerConfig[];\r\n  dependencies: EntityDependency[];\r\n  diagnostics: Diagnostic[];\r\n  metadata: AnalysisMetadata;\r\n}\r\n\r\n/**\r\n * Metadata about the analyzed program\r\n */\r\nexport interface AnalysisMetadata {\r\n  programName?: string;\r\n  inputCount: number;\r\n  outputCount: number;\r\n  triggerCount: number;\r\n  hasPersistentVars: boolean;\r\n  hasTimers: boolean;\r\n  mode?: \"single\" | \"restart\" | \"queued\" | \"parallel\";\r\n  /** Throttle value as ST-style time literal (e.g., 'T#1s') */\r\n  throttle?: string;\r\n  /** Debounce value as ST-style time literal (e.g., 'T#500ms') */\r\n  debounce?: string;\r\n}\r\n\r\n/**\r\n * Diagnostic severity levels (PascalCase per IEC 61131-3 conventions)\r\n */\r\nexport type DiagnosticSeverity = \"Error\" | \"Warning\" | \"Info\" | \"Hint\";\r\n\r\nexport interface Diagnostic {\r\n  severity: DiagnosticSeverity;\r\n  code: string;\r\n  message: string;\r\n  location?: { line: number; column: number };\r\n  relatedInfo?: string;\r\n}\r\n\r\n/**\r\n * Standard diagnostic codes\r\n * Format: W0xx (Warning), I0xx (Info), E0xx (Error), H0xx (Hint)\r\n */\r\nexport const DiagnosticCodes = {\r\n  // Warnings (W0xx)\r\n  NO_TRIGGERS: \"W001\",\r\n  MANY_TRIGGERS: \"W002\",\r\n  UNUSED_INPUT: \"W003\",\r\n  WRITE_TO_INPUT: \"W004\",\r\n  READ_FROM_OUTPUT: \"W005\",\r\n\r\n  // Info (I0xx)\r\n  AUTO_TRIGGER: \"I001\",\r\n  EXPLICIT_NO_TRIGGER: \"I002\",\r\n  EDGE_TRIGGER_DETECTED: \"I003\",\r\n\r\n  // Errors (E0xx)\r\n  INVALID_ENTITY_ID: \"E001\",\r\n  DUPLICATE_BINDING: \"E002\",\r\n  CIRCULAR_DEPENDENCY: \"E003\",\r\n\r\n  // Hints (H0xx)\r\n  CONSIDER_NO_TRIGGER: \"H001\",\r\n  CONSIDER_EDGE_TRIGGER: \"H002\",\r\n} as const;\r\n\r\n/**\r\n * Parsed pragma from code comments\r\n */\r\nexport interface ParsedPragma {\r\n  name: string;\r\n  value?: string | number | boolean;\r\n}\r\n\r\nexport interface TriggerPragmaOptions {\r\n  trigger?: boolean;\r\n  no_trigger?: boolean;\r\n  edge?: \"rising\" | \"falling\";\r\n}\r\n\r\n// ============================================================================\r\n// Storage Types\r\n// ============================================================================\r\n\r\nexport enum StorageType {\r\n  /** Entity-bound variable - value comes from entity state */\r\n  DERIVED = \"DERIVED\",\r\n\r\n  /** Temporary variable - only valid during single run */\r\n  TRANSIENT = \"TRANSIENT\",\r\n\r\n  /** Persistent variable - survives across runs via HA helper */\r\n  PERSISTENT = \"PERSISTENT\",\r\n}\r\n\r\nexport interface StorageDecision {\r\n  type: StorageType;\r\n  reason: string;\r\n  helperId?: string;\r\n  helperType?: HelperType;\r\n  initialValue?: unknown;\r\n}\r\n\r\nexport type HelperType =\r\n  | \"input_boolean\"\r\n  | \"input_number\"\r\n  | \"input_text\"\r\n  | \"input_datetime\"\r\n  | \"input_select\"\r\n  | \"counter\"\r\n  | \"timer\";\r\n\r\nexport interface HelperConfig {\r\n  id: string;\r\n  type: HelperType;\r\n  name: string;\r\n  initial?: unknown;\r\n  min?: number;\r\n  max?: number;\r\n  step?: number;\r\n  mode?: \"box\" | \"slider\";\r\n  options?: string[];\r\n  pattern?: string;\r\n}\r\n\r\nexport interface StorageAnalysisResult {\r\n  variables: VariableStorageInfo[];\r\n  helpers: HelperConfig[];\r\n  diagnostics: Diagnostic[];\r\n}\r\n\r\nexport interface VariableStorageInfo {\r\n  name: string;\r\n  dataType: string;\r\n  storage: StorageDecision;\r\n  usageInfo: VariableUsageInfo;\r\n}\r\n\r\nexport interface VariableUsageInfo {\r\n  isRead: boolean;\r\n  isWritten: boolean;\r\n  hasSelfReference: boolean;\r\n  isFBInstance: boolean;\r\n  isTimerRelated: boolean;\r\n  readCount: number;\r\n  writeCount: number;\r\n}\r\n\r\n/**\r\n * Diagnostic Codes for Storage Analysis\r\n */\r\nexport const StorageDiagnosticCodes = {\r\n  // Info\r\n  AUTO_PERSISTENT: \"I010\",\r\n  EXPLICIT_PERSISTENT: \"I011\",\r\n  EXPLICIT_TRANSIENT: \"I012\",\r\n\r\n  // Warnings\r\n  SELF_REF_NOT_PERSISTENT: \"W010\",\r\n  FB_INSTANCE_NOT_PERSISTENT: \"W011\",\r\n  UNUSED_PERSISTENT: \"W012\",\r\n\r\n  // Errors\r\n  INVALID_HELPER_TYPE: \"E010\",\r\n  CONFLICTING_PRAGMAS: \"E011\",\r\n} as const;\r\n","/**\r\n * AST Visitor - Traverses the Structured Text AST\r\n *\r\n * This module provides utilities to walk the AST and call visitor callbacks\r\n * for different types of nodes. It maintains context during traversal to help\r\n * with analysis (e.g., tracking scope, whether we're in a condition/loop, etc.).\r\n */\r\n\r\nimport type {\r\n  ProgramNode,\r\n  Statement,\r\n  Expression,\r\n  IfStatement,\r\n  CaseStatement,\r\n  ForStatement,\r\n  WhileStatement,\r\n  RepeatStatement,\r\n  AssignmentStatement,\r\n  FunctionCallStatement,\r\n  VariableRef,\r\n  MemberAccess,\r\n  BinaryExpression,\r\n  UnaryExpression,\r\n  FunctionCall,\r\n  ParenExpression,\r\n} from \"../parser/ast\";\r\n\r\n/**\r\n * Callback types for different visitor events\r\n */\r\nexport type VisitorCallback<T = any> = (\r\n  node: T,\r\n  context: VisitorContext,\r\n) => void;\r\n\r\nexport interface VisitorContext {\r\n  scope: \"PROGRAM\" | \"IF\" | \"CASE\" | \"FOR\" | \"WHILE\" | \"REPEAT\";\r\n  inCondition: boolean;\r\n  inLoop: boolean;\r\n  path: string[]; // Path of scopes, e.g., ['PROGRAM', 'IF', 'WHILE']\r\n  currentStatement?: Statement;\r\n}\r\n\r\nexport interface VisitorOptions {\r\n  onVariableRef?: VisitorCallback<VariableRef>;\r\n  onAssignment?: VisitorCallback<AssignmentStatement>;\r\n  onFunctionCall?: VisitorCallback<FunctionCall>;\r\n  onBinaryOp?: VisitorCallback<BinaryExpression>;\r\n  onStatement?: VisitorCallback<Statement>;\r\n}\r\n\r\n/**\r\n * Walk the AST and call visitor callbacks\r\n */\r\nexport function walkAST(program: ProgramNode, options: VisitorOptions): void {\r\n  const context: VisitorContext = {\r\n    scope: \"PROGRAM\",\r\n    inCondition: false,\r\n    inLoop: false,\r\n    path: [\"PROGRAM\"],\r\n  };\r\n\r\n  // Visit program body statements\r\n  visitStatements(program.body, context, options);\r\n\r\n  // Restore context\r\n  context.path.pop();\r\n}\r\n\r\nfunction visitStatements(\r\n  statements: Statement[],\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  for (const stmt of statements) {\r\n    const stmtContext = {\r\n      ...context,\r\n      currentStatement: stmt,\r\n      path: [...context.path],\r\n    };\r\n    visitStatement(stmt, stmtContext, options);\r\n  }\r\n}\r\n\r\nfunction visitStatement(\r\n  stmt: Statement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  if (options.onStatement) {\r\n    options.onStatement(stmt, context);\r\n  }\r\n\r\n  switch (stmt.type) {\r\n    case \"Assignment\":\r\n      if (options.onAssignment) {\r\n        options.onAssignment(stmt as AssignmentStatement, context);\r\n      }\r\n      visitExpression((stmt as AssignmentStatement).value, context, options);\r\n      break;\r\n\r\n    case \"IfStatement\":\r\n      visitIfStatement(stmt as IfStatement, context, options);\r\n      break;\r\n\r\n    case \"CaseStatement\":\r\n      visitCaseStatement(stmt as CaseStatement, context, options);\r\n      break;\r\n\r\n    case \"ForStatement\":\r\n      visitForStatement(stmt as ForStatement, context, options);\r\n      break;\r\n\r\n    case \"WhileStatement\":\r\n      visitWhileStatement(stmt as WhileStatement, context, options);\r\n      break;\r\n\r\n    case \"RepeatStatement\":\r\n      visitRepeatStatement(stmt as RepeatStatement, context, options);\r\n      break;\r\n\r\n    case \"FunctionCallStatement\":\r\n      if (options.onFunctionCall) {\r\n        options.onFunctionCall((stmt as FunctionCallStatement).call, context);\r\n      }\r\n      break;\r\n\r\n    case \"ReturnStatement\":\r\n    case \"ExitStatement\":\r\n      // No expressions to visit\r\n      break;\r\n  }\r\n}\r\n\r\nfunction visitIfStatement(\r\n  stmt: IfStatement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  const condContext = { ...context, inCondition: true };\r\n  visitExpression(stmt.condition, condContext, options);\r\n\r\n  context.path.push(\"IF\");\r\n  visitStatements(stmt.thenBranch, context, options);\r\n\r\n  for (const elsif of stmt.elsifBranches) {\r\n    visitExpression(elsif.condition, condContext, options);\r\n    visitStatements(elsif.body, context, options);\r\n  }\r\n\r\n  if (stmt.elseBranch) {\r\n    visitStatements(stmt.elseBranch, context, options);\r\n  }\r\n\r\n  context.path.pop();\r\n}\r\n\r\nfunction visitForStatement(\r\n  stmt: ForStatement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  const loopContext = { ...context, inLoop: true };\r\n\r\n  visitExpression(stmt.from, context, options);\r\n  visitExpression(stmt.to, context, options);\r\n  if (stmt.by) visitExpression(stmt.by, context, options);\r\n\r\n  loopContext.path.push(\"FOR\");\r\n  visitStatements(stmt.body, loopContext, options);\r\n  loopContext.path.pop();\r\n}\r\n\r\nfunction visitWhileStatement(\r\n  stmt: WhileStatement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  const loopContext = { ...context, inLoop: true, inCondition: true };\r\n  visitExpression(stmt.condition, loopContext, options);\r\n\r\n  loopContext.path.push(\"WHILE\");\r\n  loopContext.inCondition = false;\r\n  visitStatements(stmt.body, loopContext, options);\r\n  loopContext.path.pop();\r\n}\r\n\r\nfunction visitRepeatStatement(\r\n  stmt: RepeatStatement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  const loopContext = { ...context, inLoop: true };\r\n\r\n  loopContext.path.push(\"REPEAT\");\r\n  visitStatements(stmt.body, loopContext, options);\r\n  loopContext.inCondition = true;\r\n  visitExpression(stmt.condition, loopContext, options);\r\n  loopContext.path.pop();\r\n}\r\n\r\nfunction visitCaseStatement(\r\n  stmt: CaseStatement,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  const { ...condContext } = context;\r\n  condContext.inCondition = true;\r\n  visitExpression(stmt.selector, condContext, options);\r\n\r\n  context.path.push(\"CASE\");\r\n  for (const caseBlock of stmt.cases) {\r\n    for (const value of caseBlock.values) {\r\n      visitExpression(value, condContext, options);\r\n    }\r\n    visitStatements(caseBlock.body, context, options);\r\n  }\r\n\r\n  if (stmt.elseCase) {\r\n    visitStatements(stmt.elseCase, context, options);\r\n  }\r\n  context.path.pop();\r\n}\r\n\r\nfunction visitExpression(\r\n  expr: Expression,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  switch (expr.type) {\r\n    case \"VariableRef\":\r\n      if (options.onVariableRef) {\r\n        options.onVariableRef(expr as VariableRef, context);\r\n      }\r\n      break;\r\n\r\n    case \"BinaryExpression\": {\r\n      const binExpr = expr as BinaryExpression;\r\n      if (options.onBinaryOp) {\r\n        options.onBinaryOp(binExpr, context);\r\n      }\r\n      visitExpression(binExpr.left, context, options);\r\n      visitExpression(binExpr.right, context, options);\r\n      break;\r\n    }\r\n\r\n    case \"UnaryExpression\":\r\n      visitExpression((expr as UnaryExpression).operand, context, options);\r\n      break;\r\n\r\n    case \"FunctionCall\":\r\n      visitFunctionCall(expr as FunctionCall, context, options);\r\n      break;\r\n\r\n    case \"MemberAccess\":\r\n      visitExpression((expr as MemberAccess).object, context, options);\r\n      break;\r\n\r\n    case \"ParenExpression\":\r\n      visitExpression((expr as ParenExpression).expression, context, options);\r\n      break;\r\n\r\n    case \"Literal\":\r\n      // Nothing to visit\r\n      break;\r\n  }\r\n}\r\n\r\nfunction visitFunctionCall(\r\n  call: FunctionCall,\r\n  context: VisitorContext,\r\n  options: VisitorOptions,\r\n): void {\r\n  if (options.onFunctionCall) {\r\n    options.onFunctionCall(call, context);\r\n  }\r\n  for (const arg of call.arguments) {\r\n    visitExpression(arg.value, context, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Find all variable references in an expression\r\n */\r\nexport function findVariableRefs(\r\n  expr: Expression,\r\n  context: VisitorContext,\r\n): VariableRef[] {\r\n  const refs: VariableRef[] = [];\r\n\r\n  const visitor: VisitorOptions = {\r\n    onVariableRef: (ref) => {\r\n      refs.push(ref);\r\n    },\r\n  };\r\n\r\n  visitExpression(\r\n    expr,\r\n    {\r\n      scope: context.scope || \"PROGRAM\",\r\n      inCondition: context.inCondition || false,\r\n      inLoop: context.inLoop || false,\r\n      path: context.path || [\"PROGRAM\"],\r\n    },\r\n    visitor,\r\n  );\r\n\r\n  return refs;\r\n}\r\n\r\n/**\r\n * Check if an expression contains a specific variable\r\n */\r\nexport function expressionContainsVariable(\r\n  expr: Expression,\r\n  variableName: string,\r\n): boolean {\r\n  return findVariableRefs(expr, {\r\n    scope: \"PROGRAM\",\r\n    inCondition: false,\r\n    inLoop: false,\r\n    path: [],\r\n  }).some((ref) => ref.name === variableName);\r\n}\r\n","/**\r\n * Trigger Generator - Generates Home Assistant triggers\r\n *\r\n * This module contains functions to generate different types of HA triggers\r\n * based on entity types and pragmas found in the code.\r\n */\r\n\r\nimport type { TriggerConfig, ParsedPragma } from \"./types\";\r\nimport type { PragmaNode } from \"../parser/ast\";\r\n\r\n/**\r\n * Generate a standard state trigger\r\n * Fires when an entity changes state (excluding unavailable/unknown states)\r\n */\r\nexport function generateStateTrigger(\r\n  entityId: string,\r\n  options?: { id?: string },\r\n): TriggerConfig {\r\n  return {\r\n    platform: \"state\",\r\n    entity_id: entityId,\r\n    not_from: [\"unavailable\", \"unknown\"],\r\n    not_to: [\"unavailable\", \"unknown\"],\r\n    id: options?.id,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a rising edge trigger (OFF -> ON)\r\n * Used for boolean entities with {trigger: rising} pragma\r\n */\r\nexport function generateRisingEdgeTrigger(\r\n  entityId: string,\r\n  id?: string,\r\n): TriggerConfig {\r\n  return {\r\n    platform: \"state\",\r\n    entity_id: entityId,\r\n    from: \"off\",\r\n    to: \"on\",\r\n    edge: \"rising\",\r\n    id,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a falling edge trigger (ON -> OFF)\r\n * Used for boolean entities with {trigger: falling} pragma\r\n */\r\nexport function generateFallingEdgeTrigger(\r\n  entityId: string,\r\n  id?: string,\r\n): TriggerConfig {\r\n  return {\r\n    platform: \"state\",\r\n    entity_id: entityId,\r\n    from: \"on\",\r\n    to: \"off\",\r\n    edge: \"falling\",\r\n    id,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a numeric state trigger\r\n * Fires when a numeric entity crosses a threshold\r\n */\r\nexport function generateNumericStateTrigger(\r\n  entityId: string,\r\n  options?: { above?: number; below?: number; id?: string },\r\n): TriggerConfig {\r\n  return {\r\n    platform: \"numeric_state\",\r\n    entity_id: entityId,\r\n    above: options?.above,\r\n    below: options?.below,\r\n    id: options?.id,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Pragma Parsing\r\n// ============================================================================\r\n\r\n/**\r\n * Parse pragmas from AST nodes into a simpler format\r\n */\r\nexport function parsePragmas(pragmas: PragmaNode[]): ParsedPragma[] {\r\n  return pragmas.map((p) => ({\r\n    name: p.name.toLowerCase(),\r\n    value: p.value,\r\n  }));\r\n}\r\n\r\n/**\r\n * Check if a variable should trigger based on pragmas\r\n */\r\nexport function shouldTrigger(\r\n  pragmas: PragmaNode[],\r\n): boolean | \"rising\" | \"falling\" | null {\r\n  const parsed = parsePragmas(pragmas);\r\n\r\n  // Check for explicit no_trigger\r\n  if (hasPragma(parsed, \"no_trigger\")) {\r\n    return false;\r\n  }\r\n\r\n  // Check for edge pragmas\r\n  const edge = getPragmaValue(parsed, \"edge\");\r\n  if (edge === \"rising\" || edge === \"falling\") {\r\n    return edge;\r\n  }\r\n\r\n  // Check for explicit trigger\r\n  if (hasPragma(parsed, \"trigger\")) {\r\n    return true;\r\n  }\r\n\r\n  // Return null to indicate no explicit decision (use default behavior)\r\n  return null;\r\n}\r\n\r\n/**\r\n * Check if a pragma exists\r\n */\r\nexport function hasPragma(pragmas: ParsedPragma[], name: string): boolean {\r\n  return pragmas.some((p) => p.name === name);\r\n}\r\n\r\n/**\r\n * Get pragma value as string\r\n */\r\nexport function getPragmaValue(\r\n  pragmas: ParsedPragma[],\r\n  name: string,\r\n): string | undefined {\r\n  const pragma = pragmas.find((p) => p.name === name);\r\n  if (pragma?.value === undefined) return undefined;\r\n  // Convert to string if not already\r\n  return String(pragma.value);\r\n}\r\n\r\n// ============================================================================\r\n// Entity Validation\r\n// ============================================================================\r\n\r\nconst VALID_DOMAINS = [\r\n  \"sensor\",\r\n  \"binary_sensor\",\r\n  \"switch\",\r\n  \"light\",\r\n  \"input_boolean\",\r\n  \"input_number\",\r\n  \"input_select\",\r\n  \"input_text\",\r\n  \"number\",\r\n  \"select\",\r\n  \"button\",\r\n  \"climate\",\r\n  \"cover\",\r\n  \"fan\",\r\n  \"lock\",\r\n  \"media_player\",\r\n  \"automation\",\r\n  \"script\",\r\n  \"scene\",\r\n  \"timer\",\r\n  \"counter\",\r\n] as const;\r\n\r\n/**\r\n * Validate entity ID format and domain\r\n *\r\n * Valid format: domain.entity_name\r\n * Examples: sensor.temperature, light.living_room\r\n */\r\nexport function isValidEntityId(entityId: string): boolean {\r\n  if (!entityId || typeof entityId !== \"string\") {\r\n    return false;\r\n  }\r\n\r\n  // Must contain exactly one dot\r\n  const parts = entityId.split(\".\");\r\n  if (parts.length !== 2) {\r\n    return false;\r\n  }\r\n\r\n  const [domain, name] = parts;\r\n\r\n  // Domain must be valid\r\n  if (!VALID_DOMAINS.includes(domain as any)) {\r\n    return false;\r\n  }\r\n\r\n  // Name must be non-empty and contain only valid chars\r\n  if (!name || !/^[a-z0-9_]+$/.test(name)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Extract domain from entity ID\r\n */\r\nexport function getEntityDomain(entityId: string): string | null {\r\n  const parts = entityId.split(\".\");\r\n  return parts.length === 2 ? parts[0] : null;\r\n}\r\n\r\n/**\r\n * Check if an entity is a boolean type (binary_sensor, input_boolean, switch, light, etc.)\r\n */\r\nexport function isBooleanEntity(entityId: string): boolean {\r\n  const domain = getEntityDomain(entityId);\r\n  return (\r\n    domain === \"binary_sensor\" ||\r\n    domain === \"input_boolean\" ||\r\n    domain === \"switch\" ||\r\n    domain === \"light\"\r\n  );\r\n}\r\n\r\n/**\r\n * Check if an entity is a numeric type (sensor, input_number, etc.)\r\n */\r\nexport function isNumericEntity(entityId: string): boolean {\r\n  const domain = getEntityDomain(entityId);\r\n  return (\r\n    domain === \"sensor\" || domain === \"input_number\" || domain === \"number\"\r\n  );\r\n}\r\n","/**\r\n * Dependency Analyzer - Main Analysis Engine\r\n *\r\n * This module analyzes Structured Text code to:\r\n * 1. Extract entity dependencies from variable bindings\r\n * 2. Analyze variable usage patterns (reads/writes)\r\n * 3. Automatically generate Home Assistant triggers\r\n * 4. Detect edge triggers (rising/falling) including R_TRIG/F_TRIG\r\n * 5. Validate usage patterns and report diagnostics\r\n */\r\n\r\nimport type {\r\n  ProgramNode,\r\n  VariableDeclaration,\r\n  FunctionCall,\r\n} from \"../parser/ast\";\r\nimport type {\r\n  TriggerConfig,\r\n  EntityDependency,\r\n  AnalysisResult,\r\n  AnalysisMetadata,\r\n  Diagnostic,\r\n  DiagnosticSeverity,\r\n} from \"./types\";\r\nimport { DiagnosticCodes } from \"./types\";\r\nimport { walkAST, findVariableRefs } from \"./ast-visitor\";\r\nimport {\r\n  generateStateTrigger,\r\n  generateRisingEdgeTrigger,\r\n  generateFallingEdgeTrigger,\r\n  shouldTrigger,\r\n  isValidEntityId,\r\n  parsePragmas,\r\n  getPragmaValue,\r\n  hasPragma,\r\n} from \"./trigger-generator\";\r\n\r\n/**\r\n * Detected edge trigger from R_TRIG/F_TRIG function block usage\r\n */\r\ninterface DetectedEdgeTrigger {\r\n  variableName: string;\r\n  edge: \"rising\" | \"falling\";\r\n  location?: { line: number; column: number };\r\n}\r\n\r\n/**\r\n * Main dependency analyzer class\r\n */\r\nclass DependencyAnalyzer {\r\n  private ast: ProgramNode;\r\n  private dependencies: EntityDependency[] = [];\r\n  private triggers: TriggerConfig[] = [];\r\n  private diagnostics: Diagnostic[] = [];\r\n  private readVariables = new Set<string>();\r\n  private writtenVariables = new Set<string>();\r\n  private variableMap = new Map<string, VariableDeclaration>();\r\n  private detectedEdgeTriggers: DetectedEdgeTrigger[] = [];\r\n\r\n  constructor(ast: ProgramNode) {\r\n    this.ast = ast;\r\n  }\r\n\r\n  /**\r\n   * Main analysis entry point\r\n   */\r\n  public analyze(): AnalysisResult {\r\n    // Step 1: Build variable map for quick lookup\r\n    this.buildVariableMap();\r\n\r\n    // Step 2: Extract entity dependencies from variable bindings\r\n    this.extractDependencies();\r\n\r\n    // Step 3: Analyze variable usage (reads/writes) and detect R_TRIG/F_TRIG\r\n    this.analyzeUsage();\r\n\r\n    // Step 4: Generate triggers for INPUT variables\r\n    this.generateTriggers();\r\n\r\n    // Step 5: Validate and generate diagnostics\r\n    this.validate();\r\n\r\n    // Step 6: Build metadata\r\n    const metadata = this.buildMetadata();\r\n\r\n    return {\r\n      triggers: this.triggers,\r\n      dependencies: this.dependencies,\r\n      diagnostics: this.diagnostics,\r\n      metadata,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build a map of variable names to declarations for quick lookup\r\n   */\r\n  private buildVariableMap(): void {\r\n    if (!this.ast || !this.ast.variables) {\r\n      return;\r\n    }\r\n    for (const varDecl of this.ast.variables) {\r\n      this.variableMap.set(varDecl.name, varDecl);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract entity dependencies from variable bindings\r\n   */\r\n  private extractDependencies(): void {\r\n    if (!this.ast.variables) {\r\n      return;\r\n    }\r\n    for (const varDecl of this.ast.variables) {\r\n      // Use enriched EntityBinding if available, otherwise extract from initialValue\r\n      const entityId = varDecl.binding?.entityId || this.extractEntityId(varDecl);\r\n\r\n      // Only process variables with entity bindings (those with entity IDs)\r\n      if (!entityId && !varDecl.binding) {\r\n        continue;\r\n      }\r\n\r\n      // Determine direction from VAR section or binding\r\n      let direction: \"INPUT\" | \"OUTPUT\" | \"MEMORY\";\r\n      if (varDecl.section === \"VAR_INPUT\") {\r\n        direction = \"INPUT\";\r\n      } else if (varDecl.section === \"VAR_OUTPUT\") {\r\n        direction = \"OUTPUT\";\r\n      } else if (varDecl.binding) {\r\n        direction = varDecl.binding.direction;\r\n      } else {\r\n        // Variable has entity ID but no clear direction, skip\r\n        continue;\r\n      }\r\n\r\n      const dependency: EntityDependency = {\r\n        variableName: varDecl.name,\r\n        entityId,\r\n        direction,\r\n        dataType: varDecl.dataType.name,\r\n        isTrigger: false, // Will be determined later\r\n        location: varDecl.location\r\n          ? {\r\n              line: varDecl.location.startLine,\r\n              column: varDecl.location.startColumn,\r\n            }\r\n          : undefined,\r\n      };\r\n\r\n      // Validate entity ID\r\n      if (entityId && !isValidEntityId(entityId)) {\r\n        this.addDiagnostic(\r\n          \"Error\",\r\n          DiagnosticCodes.INVALID_ENTITY_ID,\r\n          `Invalid entity ID format: ${entityId}`,\r\n          dependency.location,\r\n        );\r\n      }\r\n\r\n      this.dependencies.push(dependency);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback method to extract entity ID from initialValue\r\n   * Used when EntityBinding doesn't have entityId set (backward compatibility)\r\n   */\r\n  private extractEntityId(varDecl: VariableDeclaration): string | undefined {\r\n    // Entity ID is stored in initialValue as a string literal\r\n    // Example: motion AT %I* : BOOL := 'binary_sensor.motion';\r\n    if (!varDecl.initialValue) return undefined;\r\n\r\n    if (\r\n      varDecl.initialValue.type === \"Literal\" &&\r\n      varDecl.initialValue.kind === \"string\"\r\n    ) {\r\n      return varDecl.initialValue.value as string;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Analyze variable usage patterns throughout the code\r\n   * Also detects R_TRIG/F_TRIG function block usage for edge triggers\r\n   */\r\n  private analyzeUsage(): void {\r\n    walkAST(this.ast, {\r\n      onVariableRef: (ref) => {\r\n        this.readVariables.add(ref.name);\r\n      },\r\n\r\n      onAssignment: (stmt) => {\r\n        // Mark target as written\r\n        if (typeof stmt.target === \"string\") {\r\n          this.writtenVariables.add(stmt.target);\r\n        } else {\r\n          // For member access (e.g., fb.output), mark the base variable\r\n          let current: any = stmt.target;\r\n          while (current.type === \"MemberAccess\") {\r\n            current = current.object;\r\n          }\r\n          if (current.type === \"VariableRef\") {\r\n            this.writtenVariables.add(current.name);\r\n          }\r\n        }\r\n\r\n        // Track variable refs in assignment value\r\n        const refs = findVariableRefs(stmt.value, {\r\n          scope: \"PROGRAM\",\r\n          inCondition: false,\r\n          inLoop: false,\r\n          path: [],\r\n        });\r\n        for (const ref of refs) {\r\n          this.readVariables.add(ref.name);\r\n        }\r\n      },\r\n\r\n      onFunctionCall: (call) => {\r\n        const name = call.name.toUpperCase();\r\n\r\n        // Detect R_TRIG / F_TRIG function block usage\r\n        if (name === \"R_TRIG\" || name === \"F_TRIG\") {\r\n          this.handleEdgeTriggerFB(call, name === \"R_TRIG\" ? \"rising\" : \"falling\");\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle R_TRIG/F_TRIG function block detection\r\n   * When these FBs are used on input variables, automatically generate edge triggers\r\n   */\r\n  private handleEdgeTriggerFB(call: FunctionCall, edge: \"rising\" | \"falling\"): void {\r\n    // R_TRIG/F_TRIG typically take an input variable as first argument\r\n    // or are called as: myRTrig(CLK := inputVar)\r\n    if (call.arguments.length > 0) {\r\n      const refs = findVariableRefs(call.arguments[0].value, {\r\n        scope: \"PROGRAM\",\r\n        inCondition: false,\r\n        inLoop: false,\r\n        path: [],\r\n      });\r\n\r\n      for (const ref of refs) {\r\n        const dep = this.dependencies.find((d) => d.variableName === ref.name);\r\n        if (dep && dep.direction === \"INPUT\") {\r\n          // Record the detected edge trigger\r\n          this.detectedEdgeTriggers.push({\r\n            variableName: ref.name,\r\n            edge,\r\n            location: dep.location,\r\n          });\r\n\r\n          // Emit diagnostic\r\n          this.addDiagnostic(\r\n            \"Info\",\r\n            DiagnosticCodes.EDGE_TRIGGER_DETECTED,\r\n            `${edge === \"rising\" ? \"R_TRIG\" : \"F_TRIG\"} detected on '${ref.name}' - will generate ${edge} edge trigger`,\r\n            dep.location,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate triggers based on INPUT variables and pragmas\r\n   */\r\n  private generateTriggers(): void {\r\n    for (const dep of this.dependencies) {\r\n      // Only INPUT variables can be triggers\r\n      if (dep.direction !== \"INPUT\") {\r\n        continue;\r\n      }\r\n\r\n      const varDecl = this.variableMap.get(dep.variableName);\r\n      if (!varDecl) continue;\r\n\r\n      // Check pragma for explicit trigger control\r\n      const triggerDecision = shouldTrigger(varDecl.pragmas);\r\n      const parsedPragmas = parsePragmas(varDecl.pragmas);\r\n\r\n      // Emit info diagnostic for explicit pragmas\r\n      if (hasPragma(parsedPragmas, \"trigger\")) {\r\n        this.addDiagnostic(\r\n          \"Info\",\r\n          DiagnosticCodes.AUTO_TRIGGER,\r\n          `Variable '${dep.variableName}' explicitly marked as trigger`,\r\n          dep.location,\r\n        );\r\n      }\r\n      if (hasPragma(parsedPragmas, \"no_trigger\")) {\r\n        this.addDiagnostic(\r\n          \"Info\",\r\n          DiagnosticCodes.EXPLICIT_NO_TRIGGER,\r\n          `Variable '${dep.variableName}' explicitly excluded from triggers`,\r\n          dep.location,\r\n        );\r\n      }\r\n\r\n      if (triggerDecision === false) {\r\n        // Explicit no_trigger\r\n        continue;\r\n      }\r\n\r\n      if (!dep.entityId) {\r\n        continue;\r\n      }\r\n\r\n      // Check if R_TRIG/F_TRIG was detected for this variable\r\n      const detectedEdge = this.detectedEdgeTriggers.find(\r\n        (e) => e.variableName === dep.variableName,\r\n      );\r\n\r\n      const trigger = this.createTrigger(dep, triggerDecision, detectedEdge?.edge);\r\n      if (trigger) {\r\n        this.triggers.push(trigger);\r\n        dep.isTrigger = true;\r\n      }\r\n    }\r\n\r\n    // Deduplicate triggers\r\n    this.triggers = this.deduplicateTriggers(this.triggers);\r\n  }\r\n\r\n  private deduplicateTriggers(triggers: TriggerConfig[]): TriggerConfig[] {\r\n    const seen = new Set<string>();\r\n    return triggers.filter((t) => {\r\n      // Create a unique key based on platform, entity_id, from, to\r\n      const fromStr = Array.isArray(t.from) ? t.from.join(\",\") : t.from || \"\";\r\n      const toStr = Array.isArray(t.to) ? t.to.join(\",\") : t.to || \"\";\r\n      const key = `${t.platform}:${t.entity_id}:${fromStr}:${toStr}:${t.edge || \"\"}`;\r\n      if (seen.has(key)) {\r\n        return false;\r\n      }\r\n      seen.add(key);\r\n      return true;\r\n    });\r\n  }\r\n\r\n  private createTrigger(\r\n    dep: EntityDependency,\r\n    triggerDecision: boolean | \"rising\" | \"falling\" | null,\r\n    detectedEdge?: \"rising\" | \"falling\",\r\n  ): TriggerConfig | null {\r\n    if (!dep.entityId) return null;\r\n\r\n    // Priority: pragma edge > detected edge (R_TRIG/F_TRIG) > default state trigger\r\n    const edge = triggerDecision === \"rising\" || triggerDecision === \"falling\"\r\n      ? triggerDecision\r\n      : detectedEdge;\r\n\r\n    // Handle edge triggers\r\n    if (edge === \"rising\") {\r\n      return generateRisingEdgeTrigger(dep.entityId, dep.variableName);\r\n    }\r\n    if (edge === \"falling\") {\r\n      return generateFallingEdgeTrigger(dep.entityId, dep.variableName);\r\n    }\r\n\r\n    // Default: generate state trigger\r\n    return generateStateTrigger(dep.entityId, { id: dep.variableName });\r\n  }\r\n\r\n  /**\r\n   * Validate usage patterns and generate diagnostics\r\n   */\r\n  private validate(): void {\r\n    // Check if any triggers were generated\r\n    if (this.triggers.length === 0) {\r\n      this.addDiagnostic(\r\n        \"Warning\",\r\n        DiagnosticCodes.NO_TRIGGERS,\r\n        \"No triggers detected. Program will never execute automatically. \" +\r\n          \"Add {trigger} pragma to input variables or ensure inputs are read in code.\",\r\n      );\r\n    }\r\n\r\n    // Check for too many triggers\r\n    if (this.triggers.length > 10) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        DiagnosticCodes.MANY_TRIGGERS,\r\n        `Program triggers on ${this.triggers.length} entities. ` +\r\n          \"Consider using {no_trigger} pragma on less important inputs.\",\r\n      );\r\n    }\r\n\r\n    // Check for unused INPUT variables\r\n    for (const dep of this.dependencies) {\r\n      if (\r\n        dep.direction === \"INPUT\" &&\r\n        !this.readVariables.has(dep.variableName)\r\n      ) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          DiagnosticCodes.UNUSED_INPUT,\r\n          `Input variable '${dep.variableName}' is declared but never read`,\r\n          dep.location,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for writes to INPUT variables\r\n    for (const dep of this.dependencies) {\r\n      if (\r\n        dep.direction === \"INPUT\" &&\r\n        this.writtenVariables.has(dep.variableName)\r\n      ) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          DiagnosticCodes.WRITE_TO_INPUT,\r\n          `Writing to input variable '${dep.variableName}' - this may not update the entity`,\r\n          dep.location,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for reads from OUTPUT without writes\r\n    for (const dep of this.dependencies) {\r\n      if (\r\n        dep.direction === \"OUTPUT\" &&\r\n        this.readVariables.has(dep.variableName) &&\r\n        !this.writtenVariables.has(dep.variableName)\r\n      ) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          DiagnosticCodes.READ_FROM_OUTPUT,\r\n          `Reading from output variable '${dep.variableName}' without writing - value may be stale`,\r\n          dep.location,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build metadata about the program\r\n   */\r\n  private buildMetadata(): AnalysisMetadata {\r\n    const deps = this.dependencies;\r\n    const programPragmas = parsePragmas(this.ast.pragmas);\r\n\r\n    // Check for {persistent} pragma on any variable\r\n    const hasPersistentVars = this.ast.variables.some((v) => {\r\n      const varPragmas = parsePragmas(v.pragmas);\r\n      return hasPragma(varPragmas, \"persistent\");\r\n    });\r\n\r\n    return {\r\n      programName: this.ast.name,\r\n      inputCount: deps.filter((d) => d.direction === \"INPUT\").length,\r\n      outputCount: deps.filter((d) => d.direction === \"OUTPUT\").length,\r\n      triggerCount: this.triggers.length,\r\n      hasPersistentVars,\r\n      hasTimers: this.hasTimerUsage(),\r\n      mode: getPragmaValue(programPragmas, \"mode\") as\r\n        | \"single\"\r\n        | \"restart\"\r\n        | \"queued\"\r\n        | \"parallel\"\r\n        | undefined,\r\n      // Keep throttle/debounce as ST-style time literals (strings)\r\n      throttle: getPragmaValue(programPragmas, \"throttle\"),\r\n      debounce: getPragmaValue(programPragmas, \"debounce\"),\r\n    };\r\n  }\r\n\r\n  private hasTimerUsage(): boolean {\r\n    let hasTimer = false;\r\n    const timerTypes = new Set([\"TON\", \"TOF\", \"TP\", \"TON_EDGE\"]);\r\n\r\n    walkAST(this.ast, {\r\n      onFunctionCall: (call) => {\r\n        if (hasTimer) {\r\n          return;\r\n        }\r\n\r\n        const callNameUpper = call.name.toUpperCase();\r\n\r\n        // Direct calls using FB type name (e.g. TON(IN := ...)\r\n        if (timerTypes.has(callNameUpper)) {\r\n          hasTimer = true;\r\n          return;\r\n        }\r\n\r\n        // Instance calls (e.g. myTimer(IN := ..., PT := ...))\r\n        const varDecl = this.variableMap.get(call.name);\r\n        if (varDecl) {\r\n          const typeNameUpper = varDecl.dataType.name.toUpperCase();\r\n          if (timerTypes.has(typeNameUpper)) {\r\n            hasTimer = true;\r\n          }\r\n        }\r\n      },\r\n    });\r\n\r\n    return hasTimer;\r\n  }\r\n\r\n  /**\r\n   * Add a diagnostic message\r\n   */\r\n  private addDiagnostic(\r\n    severity: DiagnosticSeverity,\r\n    code: string,\r\n    message: string,\r\n    location?: { line: number; column: number },\r\n  ): void {\r\n    this.diagnostics.push({ severity, code, message, location });\r\n  }\r\n}\r\n\r\n/**\r\n * Public API - Analyze a parsed AST\r\n */\r\nexport function analyzeDependencies(ast: ProgramNode): AnalysisResult {\r\n  const analyzer = new DependencyAnalyzer(ast);\r\n  return analyzer.analyze();\r\n}\r\n","/**\r\n * ST Data Type to HA Helper Type Mapping\r\n *\r\n * This module handles mapping between Structured Text data types and\r\n * Home Assistant helper entity types for persistent storage.\r\n */\r\n\r\nimport type { HelperType, HelperConfig } from \"./types\";\r\n\r\n// ============================================================================\r\n// Type Mapping\r\n// ============================================================================\r\n\r\ninterface TypeMapping {\r\n  helperType: HelperType;\r\n  defaultMin?: number;\r\n  defaultMax?: number;\r\n  defaultStep?: number;\r\n}\r\n\r\nconst TYPE_MAPPINGS: Record<string, TypeMapping> = {\r\n  // Boolean types\r\n  BOOL: { helperType: \"input_boolean\" },\r\n\r\n  // Integer types\r\n  SINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: -128,\r\n    defaultMax: 127,\r\n    defaultStep: 1,\r\n  },\r\n  INT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: -32768,\r\n    defaultMax: 32767,\r\n    defaultStep: 1,\r\n  },\r\n  DINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: -2147483648,\r\n    defaultMax: 2147483647,\r\n    defaultStep: 1,\r\n  },\r\n  LINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: Number.MIN_SAFE_INTEGER,\r\n    defaultMax: Number.MAX_SAFE_INTEGER,\r\n    defaultStep: 1,\r\n  },\r\n  USINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: 0,\r\n    defaultMax: 255,\r\n    defaultStep: 1,\r\n  },\r\n  UINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: 0,\r\n    defaultMax: 65535,\r\n    defaultStep: 1,\r\n  },\r\n  UDINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: 0,\r\n    defaultMax: 4294967295,\r\n    defaultStep: 1,\r\n  },\r\n  ULINT: {\r\n    helperType: \"input_number\",\r\n    defaultMin: 0,\r\n    defaultMax: Number.MAX_SAFE_INTEGER,\r\n    defaultStep: 1,\r\n  },\r\n\r\n  // Real types\r\n  REAL: {\r\n    helperType: \"input_number\",\r\n    defaultMin: -3.4e38,\r\n    defaultMax: 3.4e38,\r\n    defaultStep: 0.1,\r\n  },\r\n  LREAL: {\r\n    helperType: \"input_number\",\r\n    defaultMin: Number.MIN_SAFE_INTEGER,\r\n    defaultMax: Number.MAX_SAFE_INTEGER,\r\n    defaultStep: 0.01,\r\n  },\r\n\r\n  // String types\r\n  STRING: { helperType: \"input_text\" },\r\n  WSTRING: { helperType: \"input_text\" },\r\n\r\n  // Time types\r\n  TIME: { helperType: \"input_text\" }, // Stored as ISO duration string\r\n  DATE: { helperType: \"input_datetime\" },\r\n  TIME_OF_DAY: { helperType: \"input_datetime\" },\r\n  TOD: { helperType: \"input_datetime\" },\r\n  DATE_AND_TIME: { helperType: \"input_datetime\" },\r\n  DT: { helperType: \"input_datetime\" },\r\n};\r\n\r\n// Function Block types that need special handling\r\nconst FB_TYPES = [\r\n  \"TON\",\r\n  \"TOF\",\r\n  \"TP\",\r\n  \"R_TRIG\",\r\n  \"F_TRIG\",\r\n  \"SR\",\r\n  \"RS\",\r\n  \"CTU\",\r\n  \"CTD\",\r\n  \"CTUD\",\r\n];\r\n\r\n/**\r\n * Get the appropriate HA helper type for an ST data type\r\n */\r\nexport function getHelperType(stType: string): HelperType | null {\r\n  const normalizedType = stType.toUpperCase();\r\n  const mapping = TYPE_MAPPINGS[normalizedType];\r\n  return mapping?.helperType ?? null;\r\n}\r\n\r\n/**\r\n * Check if type is a Function Block\r\n */\r\nexport function isFunctionBlockType(stType: string): boolean {\r\n  return FB_TYPES.includes(stType.toUpperCase());\r\n}\r\n\r\n/**\r\n * Check if type is numeric (INT, REAL variants)\r\n */\r\nexport function isNumericType(stType: string): boolean {\r\n  const normalizedType = stType.toUpperCase();\r\n  return [\r\n    \"SINT\",\r\n    \"INT\",\r\n    \"DINT\",\r\n    \"LINT\",\r\n    \"USINT\",\r\n    \"UINT\",\r\n    \"UDINT\",\r\n    \"ULINT\",\r\n    \"REAL\",\r\n    \"LREAL\",\r\n  ].includes(normalizedType);\r\n}\r\n\r\n/**\r\n * Check if type is boolean\r\n */\r\nexport function isBooleanType(stType: string): boolean {\r\n  return stType.toUpperCase() === \"BOOL\";\r\n}\r\n\r\n/**\r\n * Check if type is string\r\n */\r\nexport function isStringType(stType: string): boolean {\r\n  const normalizedType = stType.toUpperCase();\r\n  return [\"STRING\", \"WSTRING\"].includes(normalizedType);\r\n}\r\n\r\n/**\r\n * Check if type is time-related\r\n */\r\nexport function isTimeType(stType: string): boolean {\r\n  const normalizedType = stType.toUpperCase();\r\n  return [\"TIME\", \"DATE\", \"TIME_OF_DAY\", \"TOD\", \"DATE_AND_TIME\", \"DT\"].includes(\r\n    normalizedType,\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Helper Config Generation\r\n// ============================================================================\r\n\r\n/**\r\n * Generate Helper ID following namespace convention\r\n * Format: input_<type>.st_<project>_<program>_<variable>\r\n */\r\nexport function generateHelperId(\r\n  projectName: string,\r\n  programName: string,\r\n  variableName: string,\r\n  helperType: HelperType,\r\n): string {\r\n  const sanitize = (s: string) => s.toLowerCase().replace(/[^a-z0-9]/g, \"_\");\r\n\r\n  const id = `st_${sanitize(projectName)}_${sanitize(programName)}_${sanitize(variableName)}`;\r\n\r\n  return `${helperType}.${id}`;\r\n}\r\n\r\n/**\r\n * Generate full helper configuration\r\n */\r\nexport function generateHelperConfig(\r\n  projectName: string,\r\n  programName: string,\r\n  variableName: string,\r\n  stType: string,\r\n  initialValue?: unknown,\r\n): HelperConfig | null {\r\n  const helperType = getHelperType(stType);\r\n  if (!helperType) {\r\n    return null;\r\n  }\r\n\r\n  const id = generateHelperId(projectName, programName, variableName, helperType);\r\n  const mapping = TYPE_MAPPINGS[stType.toUpperCase()];\r\n\r\n  const config: HelperConfig = {\r\n    id,\r\n    type: helperType,\r\n    name: `ST ${programName} - ${variableName}`,\r\n  };\r\n\r\n  // Set type-specific options\r\n  if (helperType === \"input_number\" && mapping) {\r\n    config.min = mapping.defaultMin;\r\n    config.max = mapping.defaultMax;\r\n    config.step = mapping.defaultStep;\r\n    config.mode = \"box\";\r\n\r\n    if (initialValue !== undefined && typeof initialValue === \"number\") {\r\n      config.initial = initialValue;\r\n    } else {\r\n      config.initial = 0;\r\n    }\r\n  }\r\n\r\n  if (helperType === \"input_boolean\") {\r\n    config.initial = initialValue === true;\r\n  }\r\n\r\n  if (helperType === \"input_text\") {\r\n    config.initial = typeof initialValue === \"string\" ? initialValue : \"\";\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Get default value for a data type\r\n */\r\nexport function getDefaultValue(stType: string): unknown {\r\n  const normalizedType = stType.toUpperCase();\r\n\r\n  if (isBooleanType(normalizedType)) return false;\r\n  if (isNumericType(normalizedType)) return 0;\r\n  if (isStringType(normalizedType)) return \"\";\r\n  if (isTimeType(normalizedType)) return \"PT0S\";\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Convert ST literal value to helper-compatible value\r\n */\r\nexport function convertToHelperValue(value: unknown, stType: string): unknown {\r\n  const normalizedType = stType.toUpperCase();\r\n\r\n  if (isBooleanType(normalizedType)) {\r\n    return value === true || value === \"TRUE\" || value === 1;\r\n  }\r\n\r\n  if (isNumericType(normalizedType)) {\r\n    if (typeof value === \"number\") return value;\r\n    if (typeof value === \"string\") return parseFloat(value) || 0;\r\n    return 0;\r\n  }\r\n\r\n  if (isStringType(normalizedType)) {\r\n    return String(value ?? \"\");\r\n  }\r\n\r\n  return value;\r\n}\r\n","/**\r\n * Storage Analyzer - Determine persistence requirements for variables\r\n *\r\n * Analyzes ST variables to determine which need HA helpers for\r\n * state persistence across automation runs.\r\n *\r\n * Storage Strategy (Tiered Storage):\r\n * - DERIVED: Entity-bound variables (value comes from entity state)\r\n * - TRANSIENT: Temporary variables (only valid during single run)\r\n * - PERSISTENT: Variables that need to survive across runs (via HA helpers)\r\n */\r\n\r\nimport type {\r\n  ProgramNode,\r\n  VariableDeclaration,\r\n  Expression,\r\n  AssignmentStatement,\r\n} from \"../parser/ast\";\r\nimport type {\r\n  StorageAnalysisResult,\r\n  VariableStorageInfo,\r\n  VariableUsageInfo,\r\n  HelperConfig,\r\n  Diagnostic,\r\n  DiagnosticSeverity,\r\n  StorageDecision,\r\n} from \"./types\";\r\nimport { StorageType, StorageDiagnosticCodes } from \"./types\";\r\nimport { walkAST, expressionContainsVariable } from \"./ast-visitor\";\r\nimport {\r\n  getHelperType,\r\n  isFunctionBlockType,\r\n  generateHelperConfig,\r\n  generateHelperId,\r\n  getDefaultValue,\r\n  convertToHelperValue,\r\n} from \"./helper-mapping\";\r\nimport { parsePragmas, hasPragma } from \"./trigger-generator\";\r\n\r\n// ============================================================================\r\n// Main Analyzer Class\r\n// ============================================================================\r\n\r\nexport class StorageAnalyzer {\r\n  private ast: ProgramNode;\r\n  private projectName: string;\r\n  private diagnostics: Diagnostic[] = [];\r\n  private usageMap: Map<string, VariableUsageInfo> = new Map();\r\n  private variableMap: Map<string, VariableDeclaration> = new Map();\r\n\r\n  constructor(ast: ProgramNode, projectName: string = \"default\") {\r\n    this.ast = ast;\r\n    this.projectName = projectName;\r\n  }\r\n\r\n  /**\r\n   * Run full storage analysis\r\n   */\r\n  analyze(): StorageAnalysisResult {\r\n    // Phase 1: Build variable map\r\n    this.buildVariableMap();\r\n\r\n    // Phase 2: Analyze variable usage\r\n    this.analyzeUsage();\r\n\r\n    // Phase 3: Determine storage type for each variable\r\n    const variables = this.determineStorageTypes();\r\n\r\n    // Phase 4: Generate helper configs for persistent variables\r\n    const helpers = this.generateHelperConfigs(variables);\r\n\r\n    // Phase 5: Validate\r\n    this.validate(variables);\r\n\r\n    return {\r\n      variables,\r\n      helpers,\r\n      diagnostics: this.diagnostics,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Phase 1: Build Variable Map\r\n  // ==========================================================================\r\n\r\n  private buildVariableMap(): void {\r\n    for (const varDecl of this.ast.variables) {\r\n      this.variableMap.set(varDecl.name, varDecl);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Phase 2: Analyze Usage\r\n  // ==========================================================================\r\n\r\n  private analyzeUsage(): void {\r\n    // Initialize usage info for all variables\r\n    for (const varDecl of this.ast.variables) {\r\n      this.usageMap.set(varDecl.name, {\r\n        isRead: false,\r\n        isWritten: false,\r\n        hasSelfReference: false,\r\n        isFBInstance: isFunctionBlockType(varDecl.dataType.name),\r\n        isTimerRelated: this.isTimerRelatedType(varDecl.dataType.name),\r\n        readCount: 0,\r\n        writeCount: 0,\r\n      });\r\n    }\r\n\r\n    // Track assignments to detect self-references\r\n    const assignments: Map<string, Expression[]> = new Map();\r\n\r\n    walkAST(this.ast, {\r\n      onVariableRef: (node) => {\r\n        const usage = this.usageMap.get(node.name);\r\n        if (usage) {\r\n          usage.isRead = true;\r\n          usage.readCount++;\r\n        }\r\n      },\r\n\r\n      onAssignment: (node) => {\r\n        const targetName = this.getAssignmentTargetName(node);\r\n\r\n        if (targetName) {\r\n          const usage = this.usageMap.get(targetName);\r\n          if (usage) {\r\n            usage.isWritten = true;\r\n            usage.writeCount++;\r\n          }\r\n\r\n          // Collect assignments for self-reference detection\r\n          if (!assignments.has(targetName)) {\r\n            assignments.set(targetName, []);\r\n          }\r\n          assignments.get(targetName)!.push(node.value);\r\n        }\r\n      },\r\n    });\r\n\r\n    // Detect self-references (e.g., counter := counter + 1)\r\n    for (const [varName, expressions] of assignments) {\r\n      for (const expr of expressions) {\r\n        if (expressionContainsVariable(expr, varName)) {\r\n          const usage = this.usageMap.get(varName);\r\n          if (usage) {\r\n            usage.hasSelfReference = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private getAssignmentTargetName(stmt: AssignmentStatement): string | null {\r\n    const target = stmt.target;\r\n\r\n    if (typeof target === \"string\") {\r\n      return target;\r\n    }\r\n\r\n    // target is a MemberAccess - get root variable name\r\n    // e.g., for fb.output, get 'fb'\r\n    let current: Expression = target;\r\n    while (current.type === \"MemberAccess\") {\r\n      current = current.object;\r\n    }\r\n    if (current.type === \"VariableRef\") {\r\n      return current.name;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private isTimerRelatedType(typeName: string): boolean {\r\n    return [\"TON\", \"TOF\", \"TP\", \"TIME\"].includes(typeName.toUpperCase());\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Phase 3: Determine Storage Types\r\n  // ==========================================================================\r\n\r\n  private determineStorageTypes(): VariableStorageInfo[] {\r\n    const results: VariableStorageInfo[] = [];\r\n\r\n    for (const varDecl of this.ast.variables) {\r\n      const usage = this.usageMap.get(varDecl.name)!;\r\n      const storage = this.determineStorageType(varDecl, usage);\r\n\r\n      results.push({\r\n        name: varDecl.name,\r\n        dataType: varDecl.dataType.name,\r\n        storage,\r\n        usageInfo: usage,\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  private determineStorageType(\r\n    varDecl: VariableDeclaration,\r\n    usage: VariableUsageInfo,\r\n  ): StorageDecision {\r\n    const pragmas = parsePragmas(varDecl.pragmas);\r\n\r\n    // 1. Entity-bound variables  DERIVED\r\n    if (varDecl.binding) {\r\n      return {\r\n        type: StorageType.DERIVED,\r\n        reason: \"Entity-bound variable - value comes from entity state\",\r\n      };\r\n    }\r\n\r\n    // 2. Check explicit pragmas\r\n    if (hasPragma(pragmas, \"transient\")) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        StorageDiagnosticCodes.EXPLICIT_TRANSIENT,\r\n        `Variable '${varDecl.name}' explicitly marked as transient`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return {\r\n        type: StorageType.TRANSIENT,\r\n        reason: \"Explicit {transient} pragma\",\r\n      };\r\n    }\r\n\r\n    if (hasPragma(pragmas, \"persistent\")) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        StorageDiagnosticCodes.EXPLICIT_PERSISTENT,\r\n        `Variable '${varDecl.name}' explicitly marked as persistent`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return this.createPersistentDecision(varDecl, \"Explicit {persistent} pragma\");\r\n    }\r\n\r\n    // 3. Auto-detect persistence needs\r\n\r\n    // Self-reference (counter := counter + 1)  PERSISTENT\r\n    if (usage.hasSelfReference) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        StorageDiagnosticCodes.AUTO_PERSISTENT,\r\n        `Variable '${varDecl.name}' auto-detected as persistent (self-reference)`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return this.createPersistentDecision(varDecl, \"Self-reference detected\");\r\n    }\r\n\r\n    // FB instances  PERSISTENT (they have internal state)\r\n    // Note: FBs require special serialization - helper config may not be available\r\n    if (usage.isFBInstance) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        StorageDiagnosticCodes.AUTO_PERSISTENT,\r\n        `Variable '${varDecl.name}' auto-detected as persistent (FB instance)`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return this.createFBPersistentDecision(varDecl, \"Function Block instance\");\r\n    }\r\n\r\n    // Timer-related (TIME type)  PERSISTENT\r\n    // Note: TIME types are stored as input_text with ISO duration format\r\n    if (usage.isTimerRelated) {\r\n      this.addDiagnostic(\r\n        \"Info\",\r\n        StorageDiagnosticCodes.AUTO_PERSISTENT,\r\n        `Variable '${varDecl.name}' auto-detected as persistent (timer-related)`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return this.createPersistentDecision(varDecl, \"Timer-related variable\");\r\n    }\r\n\r\n    // 4. Default  TRANSIENT\r\n    return {\r\n      type: StorageType.TRANSIENT,\r\n      reason: \"No persistence requirement detected\",\r\n    };\r\n  }\r\n\r\n  private createPersistentDecision(\r\n    varDecl: VariableDeclaration,\r\n    reason: string,\r\n  ): StorageDecision {\r\n    const helperType = getHelperType(varDecl.dataType.name);\r\n\r\n    if (!helperType) {\r\n      this.addDiagnostic(\r\n        \"Warning\",\r\n        StorageDiagnosticCodes.INVALID_HELPER_TYPE,\r\n        `Cannot create helper for type '${varDecl.dataType.name}' - using transient storage`,\r\n        varDecl.location,\r\n      );\r\n\r\n      return {\r\n        type: StorageType.TRANSIENT,\r\n        reason: `No helper type available for ${varDecl.dataType.name}`,\r\n      };\r\n    }\r\n\r\n    // Use the standard helper ID generation function for consistency\r\n    const helperId = generateHelperId(\r\n      this.projectName,\r\n      this.ast.name,\r\n      varDecl.name,\r\n      helperType,\r\n    );\r\n\r\n    // Extract initial value\r\n    let initialValue = getDefaultValue(varDecl.dataType.name);\r\n    if (varDecl.initialValue?.type === \"Literal\") {\r\n      initialValue = convertToHelperValue(\r\n        varDecl.initialValue.value,\r\n        varDecl.dataType.name,\r\n      );\r\n    }\r\n\r\n    return {\r\n      type: StorageType.PERSISTENT,\r\n      reason,\r\n      helperId,\r\n      helperType,\r\n      initialValue,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create persistent decision for Function Block instances.\r\n   * FB types (TON, R_TRIG, etc.) have internal state that requires\r\n   * special serialization - full helper generation is handled by\r\n   * the Helper Manager in a later phase.\r\n   */\r\n  private createFBPersistentDecision(\r\n    _varDecl: VariableDeclaration,\r\n    reason: string,\r\n  ): StorageDecision {\r\n    // FBs are persistent but don't have a simple helper mapping.\r\n    // The Helper Manager will handle state serialization for these.\r\n    return {\r\n      type: StorageType.PERSISTENT,\r\n      reason,\r\n      // No helperId/helperType for FBs - requires special handling\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Phase 4: Generate Helper Configs\r\n  // ==========================================================================\r\n\r\n  private generateHelperConfigs(variables: VariableStorageInfo[]): HelperConfig[] {\r\n    const helpers: HelperConfig[] = [];\r\n\r\n    for (const varInfo of variables) {\r\n      if (varInfo.storage.type !== StorageType.PERSISTENT) {\r\n        continue;\r\n      }\r\n\r\n      const config = generateHelperConfig(\r\n        this.projectName,\r\n        this.ast.name,\r\n        varInfo.name,\r\n        varInfo.dataType,\r\n        varInfo.storage.initialValue,\r\n      );\r\n\r\n      if (config) {\r\n        helpers.push(config);\r\n      }\r\n    }\r\n\r\n    return helpers;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Phase 5: Validation\r\n  // ==========================================================================\r\n\r\n  private validate(variables: VariableStorageInfo[]): void {\r\n    for (const varInfo of variables) {\r\n      const usage = varInfo.usageInfo;\r\n      const varDecl = this.variableMap.get(varInfo.name)!;\r\n      const pragmas = parsePragmas(varDecl.pragmas);\r\n\r\n      // Warn about self-referencing variables not marked as persistent\r\n      if (usage.hasSelfReference && varInfo.storage.type === StorageType.TRANSIENT) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          StorageDiagnosticCodes.SELF_REF_NOT_PERSISTENT,\r\n          `Variable '${varInfo.name}' has self-reference but is transient - value will reset each run`,\r\n          varDecl.location,\r\n        );\r\n      }\r\n\r\n      // Warn about FB instances not marked as persistent\r\n      if (usage.isFBInstance && varInfo.storage.type === StorageType.TRANSIENT) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          StorageDiagnosticCodes.FB_INSTANCE_NOT_PERSISTENT,\r\n          `Function Block '${varInfo.name}' is transient - internal state will reset each run`,\r\n          varDecl.location,\r\n        );\r\n      }\r\n\r\n      // Warn about persistent variables that are never written\r\n      if (varInfo.storage.type === StorageType.PERSISTENT && !usage.isWritten) {\r\n        this.addDiagnostic(\r\n          \"Warning\",\r\n          StorageDiagnosticCodes.UNUSED_PERSISTENT,\r\n          `Persistent variable '${varInfo.name}' is never written - consider making it transient`,\r\n          varDecl.location,\r\n        );\r\n      }\r\n\r\n      // Check for conflicting pragmas\r\n      if (hasPragma(pragmas, \"persistent\") && hasPragma(pragmas, \"transient\")) {\r\n        this.addDiagnostic(\r\n          \"Error\",\r\n          StorageDiagnosticCodes.CONFLICTING_PRAGMAS,\r\n          `Variable '${varInfo.name}' has conflicting {persistent} and {transient} pragmas`,\r\n          varDecl.location,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Helpers\r\n  // ==========================================================================\r\n\r\n  private addDiagnostic(\r\n    severity: DiagnosticSeverity,\r\n    code: string,\r\n    message: string,\r\n    location?: { startLine: number; startColumn: number },\r\n  ): void {\r\n    this.diagnostics.push({\r\n      severity,\r\n      code,\r\n      message,\r\n      location: location\r\n        ? { line: location.startLine, column: location.startColumn }\r\n        : undefined,\r\n    });\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Convenience Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Analyze storage requirements for a program AST\r\n */\r\nexport function analyzeStorage(\r\n  ast: ProgramNode,\r\n  projectName?: string,\r\n): StorageAnalysisResult {\r\n  const analyzer = new StorageAnalyzer(ast, projectName);\r\n  return analyzer.analyze();\r\n}\r\n\r\n/**\r\n * Get only the variables that need helpers\r\n */\r\nexport function getPersistentVariables(\r\n  ast: ProgramNode,\r\n  projectName?: string,\r\n): VariableStorageInfo[] {\r\n  const result = analyzeStorage(ast, projectName);\r\n  return result.variables.filter((v) => v.storage.type === StorageType.PERSISTENT);\r\n}\r\n\r\n/**\r\n * Get helper configs for a program\r\n */\r\nexport function getRequiredHelpers(\r\n  ast: ProgramNode,\r\n  projectName?: string,\r\n): HelperConfig[] {\r\n  const result = analyzeStorage(ast, projectName);\r\n  return result.helpers;\r\n}\r\n"],"names":["DiagnosticCodes","StorageType","StorageDiagnosticCodes","walkAST","program","options","context","visitStatements","statements","stmt","stmtContext","visitStatement","visitExpression","visitIfStatement","visitCaseStatement","visitForStatement","visitWhileStatement","visitRepeatStatement","condContext","elsif","loopContext","caseBlock","value","expr","binExpr","visitFunctionCall","call","arg","findVariableRefs","refs","visitor","ref","expressionContainsVariable","variableName","generateStateTrigger","entityId","generateRisingEdgeTrigger","id","generateFallingEdgeTrigger","parsePragmas","pragmas","p","shouldTrigger","parsed","hasPragma","edge","getPragmaValue","name","pragma","VALID_DOMAINS","isValidEntityId","parts","domain","DependencyAnalyzer","ast","__publicField","metadata","varDecl","_a","direction","dependency","current","dep","d","triggerDecision","parsedPragmas","detectedEdge","e","trigger","triggers","seen","t","fromStr","toStr","key","deps","programPragmas","hasPersistentVars","v","varPragmas","hasTimer","timerTypes","callNameUpper","typeNameUpper","severity","code","message","location","analyzeDependencies","TYPE_MAPPINGS","FB_TYPES","getHelperType","stType","normalizedType","mapping","isFunctionBlockType","isNumericType","isBooleanType","isStringType","isTimeType","generateHelperId","projectName","programName","helperType","sanitize","s","generateHelperConfig","initialValue","config","getDefaultValue","convertToHelperValue","StorageAnalyzer","variables","helpers","assignments","node","usage","targetName","varName","expressions","target","typeName","results","storage","reason","helperId","_varDecl","varInfo","analyzeStorage"],"mappings":"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"}