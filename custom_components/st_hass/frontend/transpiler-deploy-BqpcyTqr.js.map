{"version":3,"file":"transpiler-deploy-BqpcyTqr.js","sources":["../../../frontend/src/transpiler/jinja-generator.ts","../../../frontend/src/transpiler/action-generator.ts","../../../frontend/src/transpiler/timer-transpiler.ts","../../../frontend/src/sourcemap/source-map.ts","../../../frontend/src/transpiler/transpiler.ts","../../../frontend/src/deploy/ha-api.ts","../../../frontend/src/deploy/helper-manager.ts","../../../frontend/src/deploy/backup-manager.ts","../../../frontend/src/restore/migration-handler.ts","../../../frontend/src/deploy/deploy-manager.ts"],"sourcesContent":["/**\r\n * Defensive Jinja Template Generator\r\n * \r\n * Generates null-safe Jinja2 templates for HA that handle\r\n * unavailable, unknown, and empty states gracefully.\r\n */\r\n\r\nimport type {\r\n  Expression,\r\n  BinaryExpression,\r\n  UnaryExpression,\r\n  Literal,\r\n  VariableRef,\r\n  FunctionCall,\r\n  MemberAccess,\r\n} from \"../parser/ast\";\r\nimport type { TranspilerContext } from \"./types\";\r\nimport type { TimerOutputResolver } from \"./timer-transpiler\";\r\n\r\n// ============================================================================\r\n// Main Generator\r\n// ============================================================================\r\n\r\nexport class JinjaGenerator {\r\n  private context: TranspilerContext;\r\n  private timerResolver?: TimerOutputResolver;\r\n\r\n  constructor(context: TranspilerContext, timerResolver?: TimerOutputResolver) {\r\n    this.context = context;\r\n    this.timerResolver = timerResolver;\r\n  }\r\n\r\n  /**\r\n   * Generate a defensive Jinja template from an ST expression\r\n   */\r\n  generateExpression(expr: Expression): string {\r\n    switch (expr.type) {\r\n      case 'Literal':\r\n        return this.generateLiteral(expr);\r\n\r\n      case 'VariableRef':\r\n        return this.generateVariableRef(expr);\r\n\r\n      case 'BinaryExpression':\r\n        return this.generateBinaryExpression(expr);\r\n\r\n      case 'UnaryExpression':\r\n        return this.generateUnaryExpression(expr);\r\n\r\n      case 'FunctionCall':\r\n        return this.generateFunctionCall(expr);\r\n\r\n      case 'ParenExpression':\r\n        return `(${this.generateExpression(expr.expression)})`;\r\n\r\n      case 'MemberAccess':\r\n        return this.generateMemberAccess(expr);\r\n\r\n      default:\r\n        throw new Error(`Unknown expression type: ${(expr as any).type}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a complete condition template (wrapped in {{ }})\r\n   */\r\n  generateCondition(expr: Expression): string {\r\n    return `{{ ${this.generateExpression(expr)} }}`;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Literal Generation\r\n  // ==========================================================================\r\n\r\n  private generateLiteral(lit: Literal): string {\r\n    switch (lit.kind) {\r\n      case 'boolean':\r\n        return lit.value ? 'true' : 'false';\r\n\r\n      case 'integer':\r\n        return String(lit.value);\r\n\r\n      case 'real':\r\n        return String(lit.value);\r\n\r\n      case 'string':\r\n        {\r\n          // Escape single quotes in strings\r\n          const escaped = String(lit.value).replace(/'/g, \"\\\\'\");\r\n          return `'${escaped}'`;\r\n        }\r\n\r\n      case 'time':\r\n        // Convert ST time literal to seconds for HA\r\n        return this.convertTimeToSeconds(lit.raw);\r\n\r\n      default:\r\n        return String(lit.value);\r\n    }\r\n  }\r\n\r\n  private convertTimeToSeconds(timeLiteral: string): string {\r\n    // T#1h30m15s -> 5415\r\n    // This is a simplified conversion - expand as needed\r\n    const match = timeLiteral.match(/T#(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+)s)?(?:(\\d+)ms)?/i);\r\n    if (!match) return '0';\r\n\r\n    const hours = parseInt(match[1] || '0', 10);\r\n    const minutes = parseInt(match[2] || '0', 10);\r\n    const seconds = parseInt(match[3] || '0', 10);\r\n    const ms = parseInt(match[4] || '0', 10);\r\n\r\n    const totalSeconds = hours * 3600 + minutes * 60 + seconds + ms / 1000;\r\n    return String(totalSeconds);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Variable Reference Generation\r\n  // ==========================================================================\r\n\r\n  private generateVariableRef(ref: VariableRef): string {\r\n    const varInfo = this.context.variables.get(ref.name);\r\n\r\n    if (!varInfo) {\r\n      // Unknown variable - return as-is (might be a loop variable)\r\n      return ref.name;\r\n    }\r\n\r\n    // Entity-bound variable → read from entity state\r\n    if (varInfo.entityId) {\r\n      return this.generateEntityRead(varInfo.entityId, varInfo.dataType);\r\n    }\r\n\r\n    // Persistent variable → read from helper\r\n    if (varInfo.isPersistent && varInfo.helperId) {\r\n      return this.generateHelperRead(varInfo.helperId, varInfo.dataType);\r\n    }\r\n\r\n    // Transient variable → just the variable name (from HA variables:)\r\n    return ref.name;\r\n  }\r\n\r\n  /**\r\n   * Generate defensive entity state read\r\n   */\r\n  private generateEntityRead(entityId: string, dataType: string): string {\r\n    const state = `states('${entityId}')`;\r\n    const invalid = `['unavailable', 'unknown', 'none', '']`;\r\n\r\n    switch (dataType.toUpperCase()) {\r\n      case 'BOOL':\r\n        return `(${state} in ['on', 'true', 'True', '1'])`;\r\n\r\n      case 'INT':\r\n      case 'DINT':\r\n      case 'SINT':\r\n      case 'LINT':\r\n      case 'UINT':\r\n      case 'UDINT':\r\n      case 'USINT':\r\n      case 'ULINT':\r\n        return `(${state} | int(default=0) if ${state} not in ${invalid} else 0)`;\r\n\r\n      case 'REAL':\r\n      case 'LREAL':\r\n        return `(${state} | float(default=0.0) if ${state} not in ${invalid} else 0.0)`;\r\n\r\n      case 'STRING':\r\n      case 'WSTRING':\r\n        return `(${state} if ${state} not in ['unavailable', 'unknown'] else '')`;\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate defensive helper state read\r\n   */\r\n  private generateHelperRead(helperId: string, dataType: string): string {\r\n    const state = `states('${helperId}')`;\r\n    const invalid = `['unavailable', 'unknown', 'none', '']`;\r\n\r\n    switch (dataType.toUpperCase()) {\r\n      case 'BOOL':\r\n        return `(${state} == 'on')`;\r\n\r\n      case 'INT':\r\n      case 'DINT':\r\n      case 'SINT':\r\n      case 'LINT':\r\n      case 'UINT':\r\n      case 'UDINT':\r\n      case 'USINT':\r\n      case 'ULINT':\r\n        return `(${state} | int(default=0) if ${state} not in ${invalid} else 0)`;\r\n\r\n      case 'REAL':\r\n      case 'LREAL':\r\n        return `(${state} | float(default=0.0) if ${state} not in ${invalid} else 0.0)`;\r\n\r\n      case 'STRING':\r\n      case 'WSTRING':\r\n        return `(${state} if ${state} not in ${invalid} else '')`;\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Binary Expression Generation\r\n  // ==========================================================================\r\n\r\n  private generateBinaryExpression(expr: BinaryExpression): string {\r\n    const left = this.generateExpression(expr.left);\r\n    const right = this.generateExpression(expr.right);\r\n\r\n    switch (expr.operator.toUpperCase()) {\r\n      // Arithmetic\r\n      case '+': return `(${left} + ${right})`;\r\n      case '-': return `(${left} - ${right})`;\r\n      case '*': return `(${left} * ${right})`;\r\n      case '/': return `(${left} / ${right})`;\r\n      case 'MOD': return `(${left} % ${right})`;\r\n\r\n      // Comparison\r\n      case '=': return `(${left} == ${right})`;\r\n      case '<>': return `(${left} != ${right})`;\r\n      case '<': return `(${left} < ${right})`;\r\n      case '>': return `(${left} > ${right})`;\r\n      case '<=': return `(${left} <= ${right})`;\r\n      case '>=': return `(${left} >= ${right})`;\r\n\r\n      // Logical\r\n      case 'AND': return `(${left} and ${right})`;\r\n      case 'OR': return `(${left} or ${right})`;\r\n      case 'XOR': return `((${left} or ${right}) and not (${left} and ${right}))`;\r\n\r\n      default:\r\n        throw new Error(`Unknown operator: ${expr.operator}`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Unary Expression Generation\r\n  // ==========================================================================\r\n\r\n  private generateUnaryExpression(expr: UnaryExpression): string {\r\n    const operand = this.generateExpression(expr.operand);\r\n\r\n    switch (expr.operator.toUpperCase()) {\r\n      case 'NOT': return `(not ${operand})`;\r\n      case '-': return `(-${operand})`;\r\n      default:\r\n        throw new Error(`Unknown unary operator: ${expr.operator}`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Function Call Generation\r\n  // ==========================================================================\r\n\r\n  private generateFunctionCall(call: FunctionCall): string {\r\n    const funcName = call.name.toUpperCase();\r\n    const args = call.arguments.map(a => this.generateExpression(a.value));\r\n\r\n    // Built-in functions with null-safe implementations\r\n    switch (funcName) {\r\n      // Selection functions\r\n      case 'SEL':\r\n        return this.generateSEL(args);\r\n      case 'MUX':\r\n        return this.generateMUX(args);\r\n\r\n      // Limit functions\r\n      case 'MIN':\r\n        return `min(${args[0]}, ${args[1]})`;\r\n      case 'MAX':\r\n        return `max(${args[0]}, ${args[1]})`;\r\n      case 'LIMIT':\r\n        return this.generateLIMIT(args);\r\n\r\n      // Math functions\r\n      case 'ABS':\r\n        return `(${args[0]} | abs)`;\r\n      case 'SQRT':\r\n        return this.generateSQRT(args);\r\n      case 'TRUNC':\r\n        return `(${args[0]} | int)`;\r\n      case 'ROUND':\r\n        return `(${args[0]} | round)`;\r\n\r\n      // Type conversion\r\n      case 'TO_INT':\r\n      case 'TO_DINT':\r\n        return `(${args[0]} | int(default=0))`;\r\n      case 'TO_REAL':\r\n      case 'TO_LREAL':\r\n        return `(${args[0]} | float(default=0.0))`;\r\n      case 'TO_STRING':\r\n        return `(${args[0]} | string)`;\r\n      case 'TO_BOOL':\r\n        return `(${args[0]} | bool)`;\r\n\r\n      // String functions\r\n      case 'LEN':\r\n        return `(${args[0]} | length)`;\r\n      case 'CONCAT':\r\n        return `(${args[0]} ~ ${args[1]})`;\r\n\r\n      default:\r\n        // Unknown function - pass through (might be custom)\r\n        return `${funcName.toLowerCase()}(${args.join(', ')})`;\r\n    }\r\n  }\r\n\r\n  private generateSEL(args: string[]): string {\r\n    // SEL(G, IN0, IN1) - if G then IN1 else IN0\r\n    if (args.length < 3) {\r\n      throw new Error('SEL requires 3 arguments');\r\n    }\r\n    return `(${args[2]} if ${args[0]} else ${args[1]})`;\r\n  }\r\n\r\n  private generateMUX(args: string[]): string {\r\n    // MUX(K, IN0, IN1, ...) - select INx based on K\r\n    if (args.length < 2) {\r\n      throw new Error('MUX requires at least 2 arguments');\r\n    }\r\n    const selector = args[0];\r\n    const inputs = args.slice(1);\r\n    \r\n    // Generate nested if-else\r\n    let result = inputs[inputs.length - 1]; // Default to last\r\n    for (let i = inputs.length - 2; i >= 0; i--) {\r\n      result = `(${inputs[i]} if ${selector} == ${i} else ${result})`;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private generateLIMIT(args: string[]): string {\r\n    // LIMIT(MN, IN, MX) - clamp IN between MN and MX\r\n    if (args.length < 3) {\r\n      throw new Error('LIMIT requires 3 arguments');\r\n    }\r\n    const [mn, input, mx] = args;\r\n    return `{% set _v = ${input} %}{% if _v is number %}{{ [[${mn}, _v] | max, ${mx}] | min }}{% else %}{{ ${mn} }}{% endif %}`;\r\n  }\r\n\r\n  private generateSQRT(args: string[]): string {\r\n    // SQRT with negative number check\r\n    if (args.length < 1) {\r\n      throw new Error('SQRT requires 1 argument');\r\n    }\r\n    return `{% set _v = ${args[0]} %}{% if _v is number and _v >= 0 %}{{ _v | sqrt }}{% else %}{{ 0 }}{% endif %}`;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Member Access Generation\r\n  // ==========================================================================\r\n\r\n  private generateMemberAccess(expr: MemberAccess): string {\r\n    // Special handling for timer outputs like timer1.Q / timer1.ET\r\n    if (this.timerResolver) {\r\n      let root: Expression = expr.object;\r\n      while (root.type === \"MemberAccess\") {\r\n        root = root.object;\r\n      }\r\n      if (root.type === \"VariableRef\") {\r\n        const mapped = this.timerResolver.resolveOutput(\r\n          root.name,\r\n          expr.member.toUpperCase() === \"ET\" ? \"ET\" : \"Q\",\r\n        );\r\n        if (mapped) {\r\n          return mapped;\r\n        }\r\n      }\r\n    }\r\n\r\n    const obj = this.generateExpression(expr.object);\r\n    return `${obj}.${expr.member}`;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Convenience Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Generate a simple entity state read (without full context)\r\n */\r\nexport function generateEntityStateRead(entityId: string, dataType: string): string {\r\n  const state = `states('${entityId}')`;\r\n  const invalid = `['unavailable', 'unknown', 'none', '']`;\r\n\r\n  switch (dataType.toUpperCase()) {\r\n    case 'BOOL':\r\n      return `{{ ${state} in ['on', 'true', 'True', '1'] }}`;\r\n    case 'INT':\r\n    case 'DINT':\r\n      return `{{ ${state} | int(default=0) if ${state} not in ${invalid} else 0 }}`;\r\n    case 'REAL':\r\n    case 'LREAL':\r\n      return `{{ ${state} | float(default=0.0) if ${state} not in ${invalid} else 0.0 }}`;\r\n    default:\r\n      return `{{ ${state} }}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a throttle condition template with fallback for uninitialized helper\r\n */\r\nexport function generateThrottleCondition(lastRunHelper: string, throttleSeconds: number): string {\r\n  return `{% set last = states('${lastRunHelper}') %}\r\n{% if last in ['unknown', 'unavailable', 'none', ''] %}\r\n  true\r\n{% else %}\r\n  {{ (now() - (last | as_datetime)).total_seconds() > ${throttleSeconds} }}\r\n{% endif %}`;\r\n}\r\n","/**\r\n * Action Generator - Convert ST Statements to HA Actions\r\n */\r\n\r\nimport type {\r\n  Statement,\r\n  IfStatement,\r\n  CaseStatement,\r\n  ForStatement,\r\n  WhileStatement,\r\n  RepeatStatement,\r\n  AssignmentStatement,\r\n  FunctionCallStatement,\r\n  Expression,\r\n  FunctionCall,\r\n  MemberAccess,\r\n} from '../parser/ast';\r\nimport type {\r\n  HAAction,\r\n  HAChooseAction,\r\n  HARepeatAction,\r\n  HAServiceAction,\r\n  HAVariablesAction,\r\n  HACondition,\r\n  HATemplateCondition,\r\n  TranspilerContext,\r\n} from \"./types\";\r\nimport { JinjaGenerator } from \"./jinja-generator\";\r\nimport type { TimerOutputResolver } from \"./timer-transpiler\";\r\nimport type { SourceMapBuilder } from \"../sourcemap/source-map\";\r\n\r\nconst MAX_LOOP_ITERATIONS = 1000;\r\n\r\nexport class ActionGenerator {\r\n  private context: TranspilerContext;\r\n  private jinja: JinjaGenerator;\r\n  private sourceMap?: SourceMapBuilder;\r\n\r\n  constructor(context: TranspilerContext, timerResolver?: TimerOutputResolver, sourceMap?: SourceMapBuilder) {\r\n    this.context = context;\r\n    this.jinja = new JinjaGenerator(context, timerResolver);\r\n    this.sourceMap = sourceMap;\r\n  }\r\n\r\n  /**\r\n   * Generate HA actions from ST statements\r\n   */\r\n  generateActions(statements: Statement[]): HAAction[] {\r\n    const actions: HAAction[] = [];\r\n    statements.forEach((stmt, index) => {\r\n      if (this.sourceMap) {\r\n        this.sourceMap.pushPath(String(index));\r\n      }\r\n      const stmtActions = this.generateAction(stmt);\r\n      actions.push(...stmtActions);\r\n      if (this.sourceMap) {\r\n        this.sourceMap.popPath();\r\n      }\r\n    });\r\n    return actions;\r\n  }\r\n\r\n  /**\r\n   * Generate single HA action from ST statement\r\n   */\r\n  generateAction(stmt: Statement): HAAction[] {\r\n    switch (stmt.type) {\r\n      case 'Assignment':\r\n        return this.generateAssignment(stmt);\r\n\r\n      case 'IfStatement':\r\n        return [this.generateIf(stmt)];\r\n\r\n      case 'CaseStatement':\r\n        return [this.generateCase(stmt)];\r\n\r\n      case 'ForStatement':\r\n        return [this.generateFor(stmt)];\r\n\r\n      case 'WhileStatement':\r\n        return [this.generateWhile(stmt)];\r\n\r\n      case 'RepeatStatement':\r\n        return [this.generateRepeat(stmt)];\r\n\r\n      case 'FunctionCallStatement':\r\n        return this.generateFunctionCall(stmt);\r\n\r\n      case 'ReturnStatement':\r\n        return [{ stop: 'Return from program', error: false }];\r\n\r\n      case 'ExitStatement':\r\n        // EXIT in loops - handled by repeat structure\r\n        return [{ stop: 'Exit loop', error: false }];\r\n\r\n      default:\r\n        throw new Error(`Unknown statement type: ${(stmt as any).type}`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Assignment Generation\r\n  // ==========================================================================\r\n\r\n  private generateAssignment(stmt: AssignmentStatement): HAAction[] {\r\n    // Record source map for assignment\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'Assignment');\r\n    }\r\n\r\n    const targetName = typeof stmt.target === 'string' \r\n      ? stmt.target \r\n      : this.getTargetName(stmt.target);\r\n\r\n    const varInfo = this.context.variables.get(targetName);\r\n\r\n    if (!varInfo) {\r\n      // Unknown variable - use HA variables\r\n      return [this.generateVariableAssignment(targetName, stmt.value)];\r\n    }\r\n\r\n    // Output entity → service call\r\n    if (varInfo.isOutput && varInfo.entityId) {\r\n      return this.generateEntityWrite(varInfo.entityId, stmt.value, varInfo.dataType);\r\n    }\r\n\r\n    // Persistent variable → helper service call\r\n    if (varInfo.isPersistent && varInfo.helperId) {\r\n      return this.generateHelperWrite(varInfo.helperId, stmt.value, varInfo.dataType);\r\n    }\r\n\r\n    // Transient variable → HA variables\r\n    return [this.generateVariableAssignment(targetName, stmt.value)];\r\n  }\r\n\r\n  private getTargetName(target: string | MemberAccess): string {\r\n    if (typeof target === 'string') {\r\n      return target;\r\n    }\r\n    \r\n    // target is a MemberAccess - get root variable name\r\n    // e.g., for fb.output, get 'fb'\r\n    let current: Expression = target;\r\n    while (current.type === 'MemberAccess') {\r\n      current = current.object;\r\n    }\r\n    if (current.type === 'VariableRef') {\r\n      return current.name;\r\n    }\r\n    return 'unknown';\r\n  }\r\n\r\n  private generateVariableAssignment(name: string, value: Expression): HAVariablesAction {\r\n    return {\r\n      variables: {\r\n        [name]: `{{ ${this.jinja.generateExpression(value)} }}`,\r\n      },\r\n    };\r\n  }\r\n\r\n  private generateEntityWrite(entityId: string, value: Expression, _dataType: string): HAAction[] {\r\n    const domain = entityId.split('.')[0];\r\n    const valueExpr = this.jinja.generateExpression(value);\r\n\r\n    // Boolean entities (lights, switches, etc.)\r\n    if (_dataType.toUpperCase() === 'BOOL') {\r\n      return [{\r\n        service: `{{ '${domain}.turn_on' if ${valueExpr} else '${domain}.turn_off' }}`,\r\n        target: { entity_id: entityId },\r\n      } as HAServiceAction];\r\n    }\r\n\r\n    // Numeric entities (input_number, etc.)\r\n    if (domain === 'input_number' || domain === 'number') {\r\n      return [{\r\n        service: `${domain}.set_value`,\r\n        target: { entity_id: entityId },\r\n        data: { value: `{{ ${valueExpr} }}` },\r\n      }];\r\n    }\r\n\r\n    // Text entities\r\n    if (domain === 'input_text') {\r\n      return [{\r\n        service: 'input_text.set_value',\r\n        target: { entity_id: entityId },\r\n        data: { value: `{{ ${valueExpr} }}` },\r\n      }];\r\n    }\r\n\r\n    // Default: try to set state (might not work for all entities)\r\n    return [{\r\n      service: `${domain}.turn_on`,\r\n      target: { entity_id: entityId },\r\n    }];\r\n  }\r\n\r\n  private generateHelperWrite(helperId: string, value: Expression, _dataType: string): HAAction[] {\r\n    const domain = helperId.split('.')[0];\r\n    const valueExpr = this.jinja.generateExpression(value);\r\n\r\n    switch (domain) {\r\n      case 'input_boolean':\r\n        return [{\r\n          service: `{{ 'input_boolean.turn_on' if ${valueExpr} else 'input_boolean.turn_off' }}`,\r\n          target: { entity_id: helperId },\r\n        } as HAServiceAction];\r\n\r\n      case 'input_number':\r\n        return [{\r\n          service: 'input_number.set_value',\r\n          target: { entity_id: helperId },\r\n          data: { value: `{{ ${valueExpr} }}` },\r\n        }];\r\n\r\n      case 'input_text':\r\n        return [{\r\n          service: 'input_text.set_value',\r\n          target: { entity_id: helperId },\r\n          data: { value: `{{ ${valueExpr} }}` },\r\n        }];\r\n\r\n      case 'input_datetime':\r\n        return [{\r\n          service: 'input_datetime.set_datetime',\r\n          target: { entity_id: helperId },\r\n          data: { datetime: `{{ ${valueExpr} }}` },\r\n        }];\r\n\r\n      case 'counter':\r\n        return [{\r\n          service: 'counter.set_value',\r\n          target: { entity_id: helperId },\r\n          data: { value: `{{ ${valueExpr} }}` },\r\n        }];\r\n\r\n      default:\r\n        throw new Error(`Unknown helper type: ${domain}`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Control Flow Generation\r\n  // ==========================================================================\r\n\r\n  private generateIf(stmt: IfStatement): HAChooseAction {\r\n    // Record source map for IF statement\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'IF statement');\r\n    }\r\n\r\n    const options: HAChooseAction['choose'] = [];\r\n\r\n    // Main IF branch\r\n    options.push({\r\n      conditions: [this.generateCondition(stmt.condition)],\r\n      sequence: this.generateActions(stmt.thenBranch),\r\n    });\r\n\r\n    // ELSIF branches\r\n    for (const elsif of stmt.elsifBranches) {\r\n      options.push({\r\n        conditions: [this.generateCondition(elsif.condition)],\r\n        sequence: this.generateActions(elsif.body),\r\n      });\r\n    }\r\n\r\n    const result: HAChooseAction = { choose: options };\r\n\r\n    // ELSE branch\r\n    if (stmt.elseBranch && stmt.elseBranch.length > 0) {\r\n      result.default = this.generateActions(stmt.elseBranch);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private generateCase(stmt: CaseStatement): HAChooseAction {\r\n    // Record source map for CASE statement\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'CASE statement');\r\n    }\r\n\r\n    const selectorExpr = this.jinja.generateExpression(stmt.selector);\r\n    const options: HAChooseAction['choose'] = [];\r\n\r\n    for (const caseClause of stmt.cases) {\r\n      // Generate condition for each case value\r\n      const conditions: HACondition[] = caseClause.values.map(val => {\r\n        const valExpr = this.jinja.generateExpression(val);\r\n        return {\r\n          condition: 'template' as const,\r\n          value_template: `{{ ${selectorExpr} == ${valExpr} }}`,\r\n        };\r\n      });\r\n\r\n      // For multiple values, wrap in OR\r\n      const finalCondition: HACondition = conditions.length === 1\r\n        ? conditions[0]\r\n        : { condition: 'or', conditions };\r\n\r\n      options.push({\r\n        conditions: [finalCondition],\r\n        sequence: this.generateActions(caseClause.body),\r\n      });\r\n    }\r\n\r\n    const result: HAChooseAction = { choose: options };\r\n\r\n    if (stmt.elseCase && stmt.elseCase.length > 0) {\r\n      result.default = this.generateActions(stmt.elseCase);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private generateFor(stmt: ForStatement): HARepeatAction {\r\n    // Record source map for FOR statement\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'FOR statement');\r\n    }\r\n\r\n    // Calculate iteration count\r\n    const fromExpr = this.jinja.generateExpression(stmt.from);\r\n    const toExpr = this.jinja.generateExpression(stmt.to);\r\n    const byExpr = stmt.by ? this.jinja.generateExpression(stmt.by) : '1';\r\n\r\n    // For safety, we use a count-based repeat with calculated iterations\r\n    const countExpr = `{{ (((${toExpr}) - (${fromExpr})) / (${byExpr})) | int + 1 }}`;\r\n\r\n    // Generate loop body with index variable\r\n    const loopVarInit: HAVariablesAction = {\r\n      variables: {\r\n        [stmt.variable]: `{{ ${fromExpr} }}`,\r\n      },\r\n    };\r\n\r\n    const loopVarIncrement: HAVariablesAction = {\r\n      variables: {\r\n        [stmt.variable]: `{{ ${stmt.variable} + ${byExpr} }}`,\r\n      },\r\n    };\r\n\r\n    return {\r\n      repeat: {\r\n        count: countExpr,\r\n        sequence: [\r\n          loopVarInit,\r\n          ...this.generateActions(stmt.body),\r\n          loopVarIncrement,\r\n        ],\r\n      },\r\n    };\r\n  }\r\n\r\n  private generateWhile(stmt: WhileStatement): HARepeatAction {\r\n    // Record source map for WHILE statement\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'WHILE statement');\r\n    }\r\n\r\n    // Add safety counter to prevent infinite loops\r\n    const safetyVar = `_while_safety_${this.context.safetyCounters++}`;\r\n\r\n    const safetyInit: HAVariablesAction = {\r\n      variables: { [safetyVar]: 0 },\r\n    };\r\n\r\n    const safetyIncrement: HAVariablesAction = {\r\n      variables: { [safetyVar]: `{{ ${safetyVar} + 1 }}` },\r\n    };\r\n\r\n    const condition = this.generateCondition(stmt.condition);\r\n    const safetyCondition: HATemplateCondition = {\r\n      condition: 'template',\r\n      value_template: `{{ ${safetyVar} < ${MAX_LOOP_ITERATIONS} }}`,\r\n    };\r\n\r\n    return {\r\n      repeat: {\r\n        while: [condition, safetyCondition],\r\n        sequence: [\r\n          safetyInit,\r\n          safetyIncrement,\r\n          ...this.generateActions(stmt.body),\r\n        ],\r\n      },\r\n    };\r\n  }\r\n\r\n  private generateRepeat(stmt: RepeatStatement): HARepeatAction {\r\n    // Record source map for REPEAT statement\r\n    if (this.sourceMap && stmt.location) {\r\n      this.sourceMap.recordNode(stmt, 'REPEAT statement');\r\n    }\r\n\r\n    // Add safety counter\r\n    const safetyVar = `_repeat_safety_${this.context.safetyCounters++}`;\r\n\r\n    const safetyInit: HAVariablesAction = {\r\n      variables: { [safetyVar]: 0 },\r\n    };\r\n\r\n    const safetyIncrement: HAVariablesAction = {\r\n      variables: { [safetyVar]: `{{ ${safetyVar} + 1 }}` },\r\n    };\r\n\r\n    const condition = this.generateCondition(stmt.condition);\r\n    const safetyCondition: HATemplateCondition = {\r\n      condition: 'template',\r\n      value_template: `{{ ${safetyVar} < ${MAX_LOOP_ITERATIONS} }}`,\r\n    };\r\n\r\n    // REPEAT...UNTIL = do-while, so we use until (condition becomes true to stop)\r\n    // But also add safety to prevent infinite loops\r\n    return {\r\n      repeat: {\r\n        until: [\r\n          { condition: 'or', conditions: [condition, { condition: 'not', conditions: [safetyCondition] }] },\r\n        ],\r\n        sequence: [\r\n          safetyInit,\r\n          safetyIncrement,\r\n          ...this.generateActions(stmt.body),\r\n        ],\r\n      },\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Function Call Generation\r\n  // ==========================================================================\r\n\r\n  private generateFunctionCall(stmt: FunctionCallStatement): HAAction[] {\r\n    const funcName = stmt.call.name.toUpperCase();\r\n\r\n    // Handle special FB calls\r\n    switch (funcName) {\r\n      case 'R_TRIG':\r\n      case 'F_TRIG':\r\n        // Edge triggers are handled at trigger level, not as actions\r\n        return [];\r\n\r\n      case 'TON':\r\n      case 'TOF':\r\n      case 'TP':\r\n        // Timer FB side effects (timer.start/cancel, helper writes) are handled\r\n        // globally by the main Transpiler's timer processing. The call itself\r\n        // does not emit additional actions here.\r\n        return [];\r\n\r\n      default:\r\n        // Custom function call - might be a script call\r\n        return [{\r\n          service: `script.${funcName.toLowerCase()}`,\r\n          data: this.buildFunctionCallData(stmt.call),\r\n        }];\r\n    }\r\n  }\r\n\r\n  private buildFunctionCallData(call: FunctionCall): Record<string, unknown> {\r\n    const data: Record<string, unknown> = {};\r\n    \r\n    for (const arg of call.arguments) {\r\n      const key = arg.name || `arg_${call.arguments.indexOf(arg)}`;\r\n      data[key] = `{{ ${this.jinja.generateExpression(arg.value)} }}`;\r\n    }\r\n    \r\n    return data;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Helpers\r\n  // ==========================================================================\r\n\r\n  private generateCondition(expr: Expression): HATemplateCondition {\r\n    return {\r\n      condition: 'template',\r\n      value_template: this.jinja.generateCondition(expr),\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Timer Function Block Transpiler\r\n *\r\n * Converts ST timer FBs (TON, TOF, TP) to HA timer entities\r\n * with appropriate automation logic.\r\n *\r\n * This module is currently used in isolation (via its own tests)\r\n * and is designed to be wired into the main transpiler in a\r\n * follow-up integration step.\r\n */\r\n\r\nimport type { Expression, FunctionCall } from \"../parser/ast\";\r\nimport type {\r\n  HAAutomation,\r\n  HAAction,\r\n  HACondition,\r\n  HAServiceAction,\r\n  TranspilerContext,\r\n} from \"./types\";\r\nimport type {\r\n  TimerFBType,\r\n  TimerInstance,\r\n  TimerInputs,\r\n  TimerEntities,\r\n  TimerTranspileResult,\r\n  TimerOutputMappings,\r\n  ParsedTimerCall,\r\n} from \"./timer-types\";\r\nimport { JinjaGenerator } from \"./jinja-generator\";\r\n\r\n// ============================================================================\r\n// Main Timer Transpiler\r\n// ============================================================================\r\n\r\nexport class TimerTranspiler {\r\n  private jinja: JinjaGenerator;\r\n\r\n  constructor(_context: TranspilerContext) {\r\n    this.jinja = new JinjaGenerator(_context);\r\n  }\r\n\r\n  /**\r\n   * Check if a function call is a timer FB (by FB type name)\r\n   */\r\n  isTimerFBType(name: string): boolean {\r\n    const upper = name.toUpperCase();\r\n    return upper === \"TON\" || upper === \"TOF\" || upper === \"TP\";\r\n  }\r\n\r\n  /**\r\n   * Parse a timer FB call\r\n   *\r\n   * Note: The current parser models FB calls with `call.name` equal to the\r\n   * called symbol. Whether this is the instance name or FB type depends on\r\n   * how the ST code is written; this helper is intentionally generic and\r\n   * leaves the instance/type resolution to the caller.\r\n   */\r\n  parseTimerCall(instanceName: string, call: FunctionCall): ParsedTimerCall {\r\n    const type = call.name.toUpperCase() as TimerFBType;\r\n    const inputs: ParsedTimerCall[\"inputs\"] = {};\r\n\r\n    for (const arg of call.arguments) {\r\n      const paramName = arg.name?.toUpperCase();\r\n      if (!paramName) continue;\r\n\r\n      switch (paramName) {\r\n        case \"IN\":\r\n          inputs.IN = this.jinja.generateExpression(arg.value);\r\n          break;\r\n        case \"PT\":\r\n          inputs.PT = this.parseTimeToSeconds(arg.value);\r\n          break;\r\n        case \"R\":\r\n          inputs.R = this.jinja.generateExpression(arg.value);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return { instanceName, type, inputs };\r\n  }\r\n\r\n  /**\r\n   * Transpile a timer FB instance given its resolved type and inputs.\r\n   *\r\n   * The caller is responsible for:\r\n   * - Determining the correct `TimerInstance` (name/program/project/type)\r\n   * - Providing normalized `TimerInputs` (IN/PT Jinja expressions)\r\n   */\r\n  transpileTimer(instance: TimerInstance, inputs: TimerInputs): TimerTranspileResult {\r\n    const entities = this.generateEntityIds(instance);\r\n    const helpers = this.generateHelperConfigs(instance, entities);\r\n\r\n    switch (instance.type) {\r\n      case \"TON\":\r\n        return this.transpileTON(instance, inputs, entities, helpers);\r\n      case \"TOF\":\r\n        return this.transpileTOF(instance, inputs, entities, helpers);\r\n      case \"TP\":\r\n        return this.transpileTP(instance, inputs, entities, helpers);\r\n      default:\r\n        throw new Error(`Unknown timer type: ${instance.type}`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TON - On-Delay Timer\r\n  // ==========================================================================\r\n\r\n  private transpileTON(\r\n    instance: TimerInstance,\r\n    inputs: TimerInputs,\r\n    entities: TimerEntities,\r\n    helpers: import(\"../analyzer/types\").HelperConfig[],\r\n  ): TimerTranspileResult {\r\n    const mainActions: HAAction[] = [\r\n      {\r\n        // High-level choose block for TON behavior\r\n        // Case 1: IN = TRUE and timer idle -> start timer\r\n        // Case 2: IN = FALSE -> cancel timer and reset Q\r\n        choose: [\r\n          {\r\n            conditions: [\r\n              this.templateCondition(inputs.IN),\r\n              this.stateCondition(entities.timerId, \"idle\"),\r\n            ],\r\n            sequence: [this.timerStart(entities.timerId, inputs.PT)],\r\n          },\r\n          {\r\n            conditions: [this.templateCondition(`not (${inputs.IN})`)],\r\n            sequence: [\r\n              this.timerCancel(entities.timerId),\r\n              this.booleanTurnOff(entities.outputHelperId),\r\n            ],\r\n          },\r\n        ],\r\n      } as any,\r\n    ];\r\n\r\n    const finishedAutomation = this.generateFinishedAutomation(\r\n      instance,\r\n      entities,\r\n      inputs.IN,\r\n      [this.booleanTurnOn(entities.outputHelperId)],\r\n    );\r\n\r\n    const outputMappings: TimerOutputMappings = {\r\n      Q: `(states('${entities.outputHelperId}') == 'on')`,\r\n      ET: entities.elapsedHelperId\r\n        ? `(states('${entities.elapsedHelperId}') | float(default=0))`\r\n        : undefined,\r\n    };\r\n\r\n    return {\r\n      entities,\r\n      helpers,\r\n      mainActions,\r\n      finishedAutomation,\r\n      outputMappings,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TOF - Off-Delay Timer\r\n  // ==========================================================================\r\n\r\n  private transpileTOF(\r\n    instance: TimerInstance,\r\n    inputs: TimerInputs,\r\n    entities: TimerEntities,\r\n    helpers: import(\"../analyzer/types\").HelperConfig[],\r\n  ): TimerTranspileResult {\r\n    const mainActions: HAAction[] = [\r\n      {\r\n        choose: [\r\n          // Case 1: IN = TRUE -> cancel timer and set Q immediately\r\n          {\r\n            conditions: [this.templateCondition(inputs.IN)],\r\n            sequence: [\r\n              this.timerCancel(entities.timerId),\r\n              this.booleanTurnOn(entities.outputHelperId),\r\n            ],\r\n          },\r\n          // Case 2: IN = FALSE and Q ON and timer idle -> start timer\r\n          {\r\n            conditions: [\r\n              this.templateCondition(`not (${inputs.IN})`),\r\n              this.stateCondition(entities.outputHelperId, \"on\"),\r\n              this.stateCondition(entities.timerId, \"idle\"),\r\n            ],\r\n            sequence: [this.timerStart(entities.timerId, inputs.PT)],\r\n          },\r\n        ],\r\n      } as any,\r\n    ];\r\n\r\n    const finishedAutomation = this.generateFinishedAutomation(\r\n      instance,\r\n      entities,\r\n      `not (${inputs.IN})`,\r\n      [this.booleanTurnOff(entities.outputHelperId)],\r\n    );\r\n\r\n    const outputMappings: TimerOutputMappings = {\r\n      Q: `(states('${entities.outputHelperId}') == 'on')`,\r\n    };\r\n\r\n    return {\r\n      entities,\r\n      helpers,\r\n      mainActions,\r\n      finishedAutomation,\r\n      outputMappings,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TP - Pulse Timer\r\n  // ==========================================================================\r\n\r\n  private transpileTP(\r\n    instance: TimerInstance,\r\n    inputs: TimerInputs,\r\n    entities: TimerEntities,\r\n    helpers: import(\"../analyzer/types\").HelperConfig[],\r\n  ): TimerTranspileResult {\r\n    // Additional helper to track pulse trigger state\r\n    const pulseTriggeredId = `input_boolean.${this.sanitize(\r\n      instance.projectName,\r\n    )}_${this.sanitize(instance.programName)}_${this.sanitize(instance.name)}_triggered`;\r\n\r\n    helpers.push({\r\n      id: pulseTriggeredId,\r\n      type: \"input_boolean\",\r\n      name: `ST ${instance.programName} ${instance.name} Triggered`,\r\n      initial: false,\r\n    });\r\n\r\n    const mainActions: HAAction[] = [\r\n      {\r\n        choose: [\r\n          // Case 1: Rising edge (IN TRUE and not triggered) -> start pulse\r\n          {\r\n            conditions: [\r\n              this.templateCondition(inputs.IN),\r\n              this.stateCondition(pulseTriggeredId, \"off\"),\r\n              this.stateCondition(entities.timerId, \"idle\"),\r\n            ],\r\n            sequence: [\r\n              this.booleanTurnOn(pulseTriggeredId),\r\n              this.booleanTurnOn(entities.outputHelperId),\r\n              this.timerStart(entities.timerId, inputs.PT),\r\n            ],\r\n          },\r\n          // Case 2: IN FALSE and timer idle -> reset trigger flag\r\n          {\r\n            conditions: [\r\n              this.templateCondition(`not (${inputs.IN})`),\r\n              this.stateCondition(entities.timerId, \"idle\"),\r\n            ],\r\n            sequence: [this.booleanTurnOff(pulseTriggeredId)],\r\n          },\r\n        ],\r\n      } as any,\r\n    ];\r\n\r\n    const finishedAutomation = this.generateFinishedAutomation(\r\n      instance,\r\n      entities,\r\n      \"true\", // always execute when timer finishes\r\n      [this.booleanTurnOff(entities.outputHelperId)],\r\n    );\r\n\r\n    const outputMappings: TimerOutputMappings = {\r\n      Q: `(states('${entities.outputHelperId}') == 'on')`,\r\n    };\r\n\r\n    return {\r\n      entities,\r\n      helpers,\r\n      mainActions,\r\n      finishedAutomation,\r\n      outputMappings,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Helper Generators\r\n  // ==========================================================================\r\n\r\n  private generateEntityIds(instance: TimerInstance): TimerEntities {\r\n    const base = `st_${this.sanitize(instance.projectName)}_${this.sanitize(\r\n      instance.programName,\r\n    )}_${this.sanitize(instance.name)}`;\r\n\r\n    return {\r\n      timerId: `timer.${base}`,\r\n      outputHelperId: `input_boolean.${base}_q`,\r\n      elapsedHelperId: `input_number.${base}_et`,\r\n    };\r\n  }\r\n\r\n  private generateHelperConfigs(\r\n    instance: TimerInstance,\r\n    entities: TimerEntities,\r\n  ): import(\"../analyzer/types\").HelperConfig[] {\r\n    const baseName = `ST ${instance.programName} ${instance.name}`;\r\n\r\n    return [\r\n      {\r\n        id: entities.timerId,\r\n        type: \"timer\",\r\n        name: `${baseName} Timer`,\r\n      },\r\n      {\r\n        id: entities.outputHelperId,\r\n        type: \"input_boolean\",\r\n        name: `${baseName} Q`,\r\n        initial: false,\r\n      },\r\n    ];\r\n  }\r\n\r\n  private generateFinishedAutomation(\r\n    instance: TimerInstance,\r\n    entities: TimerEntities,\r\n    additionalCondition: string,\r\n    actions: HAAction[],\r\n  ): HAAutomation {\r\n    return {\r\n      id: `st_${this.sanitize(instance.projectName)}_${this.sanitize(\r\n        instance.programName,\r\n      )}_${this.sanitize(instance.name)}_finished`,\r\n      alias: `[ST] ${instance.programName} - ${instance.name} Finished`,\r\n      description: `Timer finished handler for ${instance.type} ${instance.name}`,\r\n      mode: \"single\",\r\n      trigger: [\r\n        {\r\n          platform: \"event\",\r\n          event_type: \"timer.finished\",\r\n          event_data: {\r\n            entity_id: entities.timerId,\r\n          },\r\n        },\r\n      ],\r\n      condition:\r\n        additionalCondition !== \"true\"\r\n          ? [\r\n              {\r\n                condition: \"template\",\r\n                value_template: `{{ ${additionalCondition} }}`,\r\n              },\r\n            ]\r\n          : undefined,\r\n      action: actions,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Action Helpers\r\n  // ==========================================================================\r\n\r\n  private timerStart(timerId: string, durationSeconds: string): HAServiceAction {\r\n    return {\r\n      service: \"timer.start\",\r\n      target: { entity_id: timerId },\r\n      data: { duration: `{{ ${durationSeconds} }}` },\r\n    };\r\n  }\r\n\r\n  private timerCancel(timerId: string): HAServiceAction {\r\n    return {\r\n      service: \"timer.cancel\",\r\n      target: { entity_id: timerId },\r\n    };\r\n  }\r\n\r\n  private booleanTurnOn(helperId: string): HAServiceAction {\r\n    return {\r\n      service: \"input_boolean.turn_on\",\r\n      target: { entity_id: helperId },\r\n    };\r\n  }\r\n\r\n  private booleanTurnOff(helperId: string): HAServiceAction {\r\n    return {\r\n      service: \"input_boolean.turn_off\",\r\n      target: { entity_id: helperId },\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Condition Helpers\r\n  // ==========================================================================\r\n\r\n  private templateCondition(expression: string): HACondition {\r\n    return {\r\n      condition: \"template\",\r\n      value_template: `{{ ${expression} }}`,\r\n    };\r\n  }\r\n\r\n  private stateCondition(entityId: string, state: string): HACondition {\r\n    return {\r\n      condition: \"state\",\r\n      entity_id: entityId,\r\n      state,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Utility Helpers\r\n  // ==========================================================================\r\n\r\n  private sanitize(s: string): string {\r\n    return s.toLowerCase().replace(/[^a-z0-9]/g, \"_\");\r\n  }\r\n\r\n  private parseTimeToSeconds(expr: Expression): string {\r\n    if (expr.type === \"Literal\" && expr.kind === \"time\") {\r\n      // Parse T#1h30m15s format\r\n      const raw = expr.raw;\r\n      const match = raw.match(/T#(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+)s)?(?:(\\d+)ms)?/i);\r\n      if (match) {\r\n        const hours = parseInt(match[1] || \"0\", 10);\r\n        const minutes = parseInt(match[2] || \"0\", 10);\r\n        const seconds = parseInt(match[3] || \"0\", 10);\r\n        const ms = parseInt(match[4] || \"0\", 10);\r\n        const total = hours * 3600 + minutes * 60 + seconds + ms / 1000;\r\n        return String(total);\r\n      }\r\n    }\r\n\r\n    // For variable expressions or non-time literals, treat as Jinja expression\r\n    return this.jinja.generateExpression(expr);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Timer Output Resolver\r\n// ============================================================================\r\n\r\n/**\r\n * Resolve timer output references in expressions.\r\n *\r\n * When code references `timer1.Q`, this can be used to map that to the\r\n * appropriate Jinja expression for the underlying helper entity.\r\n *\r\n * Note: Wiring into the main `JinjaGenerator` is planned but not required\r\n * for the core timer transpiler tests in this phase.\r\n */\r\nexport class TimerOutputResolver {\r\n  private timerMappings: Map<string, TimerOutputMappings> = new Map();\r\n\r\n  registerTimer(instanceName: string, mappings: TimerOutputMappings): void {\r\n    this.timerMappings.set(instanceName, mappings);\r\n  }\r\n\r\n  resolveOutput(instanceName: string, output: \"Q\" | \"ET\"): string | null {\r\n    const mappings = this.timerMappings.get(instanceName);\r\n    if (!mappings) return null;\r\n\r\n    switch (output) {\r\n      case \"Q\":\r\n        return mappings.Q;\r\n      case \"ET\":\r\n        return mappings.ET ?? null;\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a variable/member pair refers to a known timer output.\r\n   */\r\n  isTimerOutputRef(varName: string, member: string): boolean {\r\n    if (!this.timerMappings.has(varName)) return false;\r\n    const upper = member.toUpperCase();\r\n    return upper === \"Q\" || upper === \"ET\";\r\n  }\r\n}\r\n\r\n","/**\r\n * Source Map Generator\r\n * \r\n * Records mappings between generated YAML paths and original ST source locations.\r\n */\r\n\r\nimport type {\r\n  SourceLocation,\r\n  SourceMapEntry,\r\n  SourceMap,\r\n  YAMLPath,\r\n  EmbeddedSourceMap,\r\n} from './source-map-types';\r\n\r\n// ============================================================================\r\n// Source Map Builder\r\n// ============================================================================\r\n\r\nexport class SourceMapBuilder {\r\n  private mappings: Map<YAMLPath, SourceMapEntry> = new Map();\r\n  private currentPath: string[] = [];\r\n  \r\n  private project: string;\r\n  private program: string;\r\n  private sourceFile: string;\r\n  private sourceHash: string;\r\n\r\n  constructor(options: {\r\n    project: string;\r\n    program: string;\r\n    sourceFile: string;\r\n    sourceContent: string;\r\n  }) {\r\n    this.project = options.project;\r\n    this.program = options.program;\r\n    this.sourceFile = options.sourceFile;\r\n    this.sourceHash = this.hashContent(options.sourceContent);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Path Management\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Push a path segment (e.g., entering an action array)\r\n   */\r\n  pushPath(segment: string | number): void {\r\n    this.currentPath.push(String(segment));\r\n  }\r\n\r\n  /**\r\n   * Pop the last path segment\r\n   */\r\n  popPath(): void {\r\n    this.currentPath.pop();\r\n  }\r\n\r\n  /**\r\n   * Get current YAML path as string\r\n   */\r\n  getCurrentPath(): YAMLPath {\r\n    return this.currentPath.join('.');\r\n  }\r\n\r\n  /**\r\n   * Execute function with temporary path segment\r\n   */\r\n  withPath<T>(segment: string | number, fn: () => T): T {\r\n    this.pushPath(segment);\r\n    try {\r\n      return fn();\r\n    } finally {\r\n      this.popPath();\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Recording Mappings\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Record a mapping at the current path\r\n   */\r\n  record(location: Partial<SourceLocation> & { line: number; column: number }, description?: string): void {\r\n    const path = this.getCurrentPath();\r\n    if (path) {\r\n      this.mappings.set(path, {\r\n        st: {\r\n          file: this.sourceFile,\r\n          line: location.line,\r\n          column: location.column,\r\n          endLine: location.endLine,\r\n          endColumn: location.endColumn,\r\n        },\r\n        description,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a mapping at a specific path\r\n   */\r\n  recordAt(path: YAMLPath, location: Partial<SourceLocation> & { line: number; column: number }, description?: string): void {\r\n    this.mappings.set(path, {\r\n      st: {\r\n        file: this.sourceFile,\r\n        line: location.line,\r\n        column: location.column,\r\n        endLine: location.endLine,\r\n        endColumn: location.endColumn,\r\n      },\r\n      description,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Record mapping for an AST node\r\n   * Handles both parser SourceLocation (startLine/startColumn) and sourcemap SourceLocation (line/column)\r\n   */\r\n  recordNode(node: { location?: any }, description?: string): void {\r\n    if (!node.location) return;\r\n    \r\n    // Convert parser SourceLocation format to sourcemap format\r\n    const location: SourceLocation = {\r\n      file: this.sourceFile,\r\n      line: node.location.startLine ?? node.location.line ?? 1,\r\n      column: node.location.startColumn ?? node.location.column ?? 1,\r\n    };\r\n    \r\n    if (node.location.endLine) {\r\n      location.endLine = node.location.endLine;\r\n    }\r\n    if (node.location.endColumn) {\r\n      location.endColumn = node.location.endColumn;\r\n    }\r\n    \r\n    this.record(location, description);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Building Output\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Build the complete source map\r\n   */\r\n  build(automationId: string, scriptId?: string): SourceMap {\r\n    return {\r\n      version: 1,\r\n      project: this.project,\r\n      program: this.program,\r\n      automationId,\r\n      scriptId,\r\n      generatedAt: new Date().toISOString(),\r\n      mappings: Object.fromEntries(this.mappings),\r\n      sourceHash: this.sourceHash,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build source map for embedding in YAML variables\r\n   */\r\n  buildEmbedded(): EmbeddedSourceMap {\r\n    return {\r\n      _st_source_map: Object.fromEntries(this.mappings),\r\n      _st_source_file: this.sourceFile,\r\n      _st_source_hash: this.sourceHash,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export mappings as JSON string (for storage)\r\n   */\r\n  toJSON(): string {\r\n    return JSON.stringify(this.build(''), null, 2);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Utilities\r\n  // ==========================================================================\r\n\r\n  private hashContent(content: string): string {\r\n    // Simple hash for change detection\r\n    let hash = 0;\r\n    for (let i = 0; i < content.length; i++) {\r\n      const char = content.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32bit integer\r\n    }\r\n    return hash.toString(16);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Source Map Reader\r\n// ============================================================================\r\n\r\nexport class SourceMapReader {\r\n  private sourceMap: SourceMap;\r\n\r\n  constructor(sourceMap: SourceMap) {\r\n    this.sourceMap = sourceMap;\r\n  }\r\n\r\n  /**\r\n   * Look up ST location for a YAML path\r\n   */\r\n  lookup(yamlPath: YAMLPath): SourceMapEntry | null {\r\n    // Exact match\r\n    if (this.sourceMap.mappings[yamlPath]) {\r\n      return this.sourceMap.mappings[yamlPath];\r\n    }\r\n\r\n    // Try parent paths\r\n    const parts = yamlPath.split('.');\r\n    while (parts.length > 0) {\r\n      parts.pop();\r\n      const parentPath = parts.join('.');\r\n      if (this.sourceMap.mappings[parentPath]) {\r\n        return this.sourceMap.mappings[parentPath];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Find all mappings within a path prefix\r\n   */\r\n  findByPrefix(prefix: YAMLPath): Array<{ path: YAMLPath; entry: SourceMapEntry }> {\r\n    const results: Array<{ path: YAMLPath; entry: SourceMapEntry }> = [];\r\n    \r\n    for (const [path, entry] of Object.entries(this.sourceMap.mappings)) {\r\n      if (path.startsWith(prefix)) {\r\n        results.push({ path, entry });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Get all mappings for a specific ST line\r\n   */\r\n  findByLine(file: string, line: number): Array<{ path: YAMLPath; entry: SourceMapEntry }> {\r\n    const results: Array<{ path: YAMLPath; entry: SourceMapEntry }> = [];\r\n    \r\n    for (const [path, entry] of Object.entries(this.sourceMap.mappings)) {\r\n      if (entry.st.file === file && entry.st.line === line) {\r\n        results.push({ path, entry });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Validate source map against current source\r\n   */\r\n  validateHash(currentContent: string): boolean {\r\n    if (!this.sourceMap.sourceHash) return true;\r\n    \r\n    let hash = 0;\r\n    for (let i = 0; i < currentContent.length; i++) {\r\n      const char = currentContent.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    \r\n    return hash.toString(16) === this.sourceMap.sourceHash;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Integration with Transpiler\r\n// ============================================================================\r\n\r\n/**\r\n * Create a source map builder integrated with transpiler context\r\n */\r\nexport function createSourceMapBuilder(\r\n  project: string,\r\n  program: string,\r\n  sourceFile: string,\r\n  sourceContent: string\r\n): SourceMapBuilder {\r\n  return new SourceMapBuilder({\r\n    project,\r\n    program,\r\n    sourceFile,\r\n    sourceContent,\r\n  });\r\n}\r\n","/**\r\n * Main Transpiler - ST AST to HA Automation/Script\r\n */\r\n\r\nimport type { ProgramNode } from \"../parser/ast\";\r\nimport type { AnalysisResult } from \"../analyzer/types\";\r\nimport type {\r\n  StorageAnalysisResult,\r\n  HelperConfig,\r\n} from \"../analyzer/types\";\r\nimport type {\r\n  TranspilerResult,\r\n  HAAutomation,\r\n  HAScript,\r\n  TranspilerContext,\r\n  VariableInfo,\r\n  EntityInfo,\r\n  TranspilerDiagnostic,\r\n  HATrigger,\r\n  HAAction,\r\n} from \"./types\";\r\nimport { analyzeDependencies } from \"../analyzer/dependency-analyzer\";\r\nimport { analyzeStorage } from \"../analyzer/storage-analyzer\";\r\nimport { ActionGenerator } from \"./action-generator\";\r\nimport { parsePragmas } from \"../analyzer/trigger-generator\";\r\nimport { TimerTranspiler, TimerOutputResolver } from \"./timer-transpiler\";\r\nimport { walkAST } from \"../analyzer/ast-visitor\";\r\nimport type { TimerInstance, TimerInputs } from \"./timer-types\";\r\nimport { SourceMapBuilder } from \"../sourcemap/source-map\";\r\n\r\nexport class Transpiler {\r\n  private ast: ProgramNode;\r\n  private projectName: string;\r\n  private depAnalysis!: AnalysisResult;\r\n  private storageAnalysis!: StorageAnalysisResult;\r\n  private context!: TranspilerContext;\r\n  private sourceMapBuilder?: SourceMapBuilder;\r\n  private diagnostics: TranspilerDiagnostic[] = [];\r\n  private timerTranspiler?: TimerTranspiler;\r\n  private timerResolver?: TimerOutputResolver;\r\n  private timerHelpers: HelperConfig[] = [];\r\n  private additionalAutomations: HAAutomation[] = [];\r\n  private timerMainActions: HAAction[] = [];\r\n\r\n  constructor(ast: ProgramNode, projectName: string = 'default', sourceContent?: string) {\r\n    this.ast = ast;\r\n    this.projectName = projectName;\r\n    \r\n    // Initialize source map builder if source content is provided\r\n    if (sourceContent) {\r\n      this.sourceMapBuilder = new SourceMapBuilder({\r\n        project: projectName,\r\n        program: ast.name,\r\n        sourceFile: `${ast.name}.st`,\r\n        sourceContent: sourceContent, // Explicitly use parameter to avoid TS6133\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transpile AST to HA automation and script\r\n   */\r\n  transpile(): TranspilerResult {\r\n    // Phase 1: Run analyzers\r\n    this.depAnalysis = analyzeDependencies(this.ast);\r\n    this.storageAnalysis = analyzeStorage(this.ast, this.projectName);\r\n\r\n    // Collect diagnostics from analyzers\r\n    this.diagnostics.push(\r\n      ...this.depAnalysis.diagnostics.map(d => ({\r\n        severity: d.severity as 'Error' | 'Warning' | 'Info',\r\n        code: d.code,\r\n        message: d.message,\r\n        stLine: d.location?.line,\r\n      })),\r\n      ...this.storageAnalysis.diagnostics.map(d => ({\r\n        severity: d.severity as 'Error' | 'Warning' | 'Info',\r\n        code: d.code,\r\n        message: d.message,\r\n        stLine: d.location?.line,\r\n      }))\r\n    );\r\n\r\n    // Phase 2: Build transpiler context\r\n    this.buildContext();\r\n\r\n    // Phase 3: Initialize timer transpiler and process timer FBs\r\n    this.timerTranspiler = new TimerTranspiler(this.context);\r\n    this.timerResolver = new TimerOutputResolver();\r\n    this.processTimerFBs();\r\n\r\n    // Phase 4: Generate automation (triggers)\r\n    const automation = this.generateAutomation();\r\n\r\n    // Phase 5: Generate script (logic)\r\n    const script = this.generateScript();\r\n\r\n    // Phase 6: Collect helpers (storage + timers)\r\n    const helpers = [...this.storageAnalysis.helpers, ...this.timerHelpers];\r\n\r\n    // Phase 7: Build source map\r\n    const sourceMap = this.sourceMapBuilder\r\n      ? this.sourceMapBuilder.build(automation.id, script.alias.replace(/\\[ST\\]\\s*/, '').toLowerCase().replace(/[^a-z0-9_]/g, '_'))\r\n      : {\r\n          version: 1 as const,\r\n          project: this.projectName,\r\n          program: this.ast.name,\r\n          automationId: automation.id,\r\n          generatedAt: new Date().toISOString(),\r\n          mappings: {},\r\n        };\r\n\r\n    return {\r\n      automation,\r\n      script,\r\n      helpers,\r\n      additionalAutomations: this.additionalAutomations,\r\n      sourceMap,\r\n      diagnostics: this.diagnostics,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Context Building\r\n  // ==========================================================================\r\n\r\n  private buildContext(): void {\r\n    const variables = new Map<string, VariableInfo>();\r\n    const entityBindings = new Map<string, EntityInfo>();\r\n\r\n    // Build variable info map\r\n    for (const varDecl of this.ast.variables) {\r\n      const storageInfo = this.storageAnalysis.variables.find(v => v.name === varDecl.name);\r\n      const depInfo = this.depAnalysis.dependencies.find(d => d.variableName === varDecl.name);\r\n\r\n      const varInfo: VariableInfo = {\r\n        name: varDecl.name,\r\n        dataType: varDecl.dataType.name,\r\n        isInput: varDecl.binding?.direction === 'INPUT' || varDecl.section === 'VAR_INPUT',\r\n        isOutput: varDecl.binding?.direction === 'OUTPUT' || varDecl.section === 'VAR_OUTPUT',\r\n        isPersistent: storageInfo?.storage.type === 'PERSISTENT',\r\n        helperId: storageInfo?.storage.helperId,\r\n        entityId: depInfo?.entityId || varDecl.binding?.entityId,\r\n      };\r\n\r\n      variables.set(varDecl.name, varInfo);\r\n\r\n      // Build entity binding map\r\n      if (depInfo && depInfo.entityId) {\r\n        // Only include INPUT/OUTPUT, skip MEMORY for now\r\n        if (depInfo.direction === 'INPUT' || depInfo.direction === 'OUTPUT') {\r\n          entityBindings.set(varDecl.name, {\r\n            entityId: depInfo.entityId,\r\n            variableName: varDecl.name,\r\n            direction: depInfo.direction,\r\n            dataType: varDecl.dataType.name,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    this.context = {\r\n      programName: this.ast.name,\r\n      projectName: this.projectName,\r\n      variables,\r\n      entityBindings,\r\n      currentPath: [],\r\n      loopDepth: 0,\r\n      safetyCounters: 0,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Timer FB Processing\r\n  // ==========================================================================\r\n\r\n  private processTimerFBs(): void {\r\n    if (!this.timerTranspiler || !this.timerResolver) {\r\n      return;\r\n    }\r\n\r\n    const timerVars = new Map<string, TimerInstance[\"type\"]>();\r\n    for (const varDecl of this.ast.variables) {\r\n      const typeName = varDecl.dataType.name.toUpperCase();\r\n      if (typeName === \"TON\" || typeName === \"TOF\" || typeName === \"TP\") {\r\n        timerVars.set(varDecl.name, typeName as TimerInstance[\"type\"]);\r\n      }\r\n    }\r\n\r\n    if (timerVars.size === 0) {\r\n      return;\r\n    }\r\n\r\n    walkAST(this.ast, {\r\n      onFunctionCall: (call) => {\r\n        const timerType = timerVars.get(call.name);\r\n        if (!timerType) {\r\n          return;\r\n        }\r\n\r\n        const instance: TimerInstance = {\r\n          name: call.name,\r\n          type: timerType,\r\n          programName: this.ast.name,\r\n          projectName: this.projectName,\r\n        };\r\n\r\n        const parsed = this.timerTranspiler!.parseTimerCall(call.name, call);\r\n        const inputs: TimerInputs = {\r\n          IN: parsed.inputs.IN ?? \"true\",\r\n          PT: parsed.inputs.PT ?? \"0\",\r\n        };\r\n\r\n        const result = this.timerTranspiler!.transpileTimer(instance, inputs);\r\n\r\n        this.timerHelpers.push(...result.helpers);\r\n        this.additionalAutomations.push(result.finishedAutomation);\r\n        this.timerMainActions.push(...result.mainActions);\r\n        this.timerResolver!.registerTimer(instance.name, result.outputMappings);\r\n      },\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Automation Generation\r\n  // ==========================================================================\r\n\r\n  private generateAutomation(): HAAutomation {\r\n    const pragmas = parsePragmas(this.ast.pragmas);\r\n    const throttle = pragmas.find(p => p.name === 'throttle')?.value as string | undefined;\r\n    const debounce = pragmas.find(p => p.name === 'debounce')?.value as string | undefined;\r\n\r\n    const automation: HAAutomation = {\r\n      id: `st_${this.projectName}_${this.ast.name}`.toLowerCase().replace(/[^a-z0-9_]/g, '_'),\r\n      alias: `[ST] ${this.ast.name}`,\r\n      description: `Generated from ST program: ${this.ast.name}`,\r\n      mode: 'single', // Automation is just dispatcher\r\n      trigger: this.depAnalysis.triggers.map(t => this.mapTriggerConfig(t)),\r\n      action: [],\r\n    };\r\n\r\n    // Add throttle condition if specified\r\n    if (throttle) {\r\n      const throttleHelper = `input_datetime.st_${this.projectName}_${this.ast.name}_last_run`.toLowerCase().replace(/[^a-z0-9_]/g, '_');\r\n      const throttleSeconds = this.parseTimeToSeconds(throttle);\r\n\r\n      automation.condition = [{\r\n        condition: 'template',\r\n        value_template: this.generateThrottleCondition(throttleHelper, throttleSeconds),\r\n      }];\r\n\r\n      // Add action to update last run time\r\n      automation.action.push({\r\n        service: 'input_datetime.set_datetime',\r\n        target: { entity_id: throttleHelper },\r\n        data: { datetime: '{{ now().isoformat() }}' },\r\n      });\r\n    }\r\n\r\n    // Add debounce delay if specified\r\n    if (debounce) {\r\n      automation.mode = 'restart'; // Restart = debounce effect\r\n      const debounceSeconds = this.parseTimeToSeconds(debounce);\r\n      automation.action.push({\r\n        delay: { seconds: debounceSeconds },\r\n      });\r\n    }\r\n\r\n    // Call the logic script\r\n    automation.action.push({\r\n      service: 'script.turn_on',\r\n      target: {\r\n        entity_id: `script.st_${this.projectName}_${this.ast.name}_logic`.toLowerCase().replace(/[^a-z0-9_]/g, '_'),\r\n      },\r\n    });\r\n\r\n    return automation;\r\n  }\r\n\r\n  private generateThrottleCondition(helperId: string, seconds: number): string {\r\n    return `{% set last = states('${helperId}') %}\r\n{% if last in ['unknown', 'unavailable', 'none', ''] %}\r\n  true\r\n{% else %}\r\n  {{ (now() - (last | as_datetime)).total_seconds() > ${seconds} }}\r\n{% endif %}`;\r\n  }\r\n\r\n  private parseTimeToSeconds(timeLiteral: string): number {\r\n    // Parse T#1h30m15s format\r\n    const match = timeLiteral.match(/T#(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+)s)?(?:(\\d+)ms)?/i);\r\n    if (!match) return 0;\r\n\r\n    const hours = parseInt(match[1] || '0', 10);\r\n    const minutes = parseInt(match[2] || '0', 10);\r\n    const seconds = parseInt(match[3] || '0', 10);\r\n    const ms = parseInt(match[4] || '0', 10);\r\n\r\n    return hours * 3600 + minutes * 60 + seconds + ms / 1000;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Trigger Mapping\r\n  // ==========================================================================\r\n\r\n  private mapTriggerConfig(t: import('../analyzer/types').TriggerConfig): HATrigger {\r\n    switch (t.platform) {\r\n      case 'state':\r\n        return {\r\n          platform: 'state',\r\n          entity_id: t.entity_id!,\r\n          from: t.from,\r\n          to: t.to,\r\n          not_from: t.not_from,\r\n          not_to: t.not_to,\r\n          attribute: t.attribute,\r\n          for: t.for,\r\n          id: t.id,\r\n        };\r\n      case 'numeric_state':\r\n        return {\r\n          platform: 'numeric_state',\r\n          entity_id: t.entity_id!,\r\n          above: t.above,\r\n          below: t.below,\r\n          attribute: t.attribute,\r\n          for: t.for,\r\n          id: t.id,\r\n        };\r\n      case 'event':\r\n        return {\r\n          platform: 'event',\r\n          event_type: t.event_type!,\r\n          event_data: t.event_data,\r\n          id: t.id,\r\n        };\r\n      case 'time':\r\n        return {\r\n          platform: 'time',\r\n          at: t.at!,\r\n          id: t.id,\r\n        };\r\n      default:\r\n        // Fallback to state trigger\r\n        return {\r\n          platform: 'state',\r\n          entity_id: t.entity_id || '',\r\n          id: t.id,\r\n        };\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Script Generation\r\n  // ==========================================================================\r\n\r\n  private generateScript(): HAScript {\r\n    const pragmas = parsePragmas(this.ast.pragmas);\r\n    const mode =\r\n      (pragmas.find((p) => p.name === \"mode\")?.value as string) || \"restart\";\r\n\r\n    const actionGenerator = new ActionGenerator(this.context, this.timerResolver, this.sourceMapBuilder);\r\n\r\n    const script: HAScript = {\r\n      alias: `[ST] ${this.ast.name} Logic`,\r\n      description: `Logic script for ST program: ${this.ast.name}`,\r\n      mode: mode as HAScript['mode'],\r\n      sequence: [],\r\n    };\r\n\r\n    // Initialize transient variables\r\n    const initVars = this.generateVariableInitializers();\r\n    if (Object.keys(initVars).length > 0) {\r\n      script.variables = initVars;\r\n    }\r\n\r\n    // Generate actions from body and prepend timer main actions\r\n    // Set up source map path context for script sequence\r\n    if (this.sourceMapBuilder) {\r\n      this.sourceMapBuilder.pushPath('sequence');\r\n    }\r\n    const bodyActions = actionGenerator.generateActions(this.ast.body);\r\n    if (this.sourceMapBuilder) {\r\n      this.sourceMapBuilder.popPath();\r\n    }\r\n    script.sequence = [...this.timerMainActions, ...bodyActions];\r\n\r\n    // Embed source map in script variables if available\r\n    // Note: Embedded source map is stored as JSON string to match Record<string, string> type\r\n    if (this.sourceMapBuilder) {\r\n      const embedded = this.sourceMapBuilder.buildEmbedded();\r\n      if (script.variables) {\r\n        script.variables = {\r\n          ...script.variables,\r\n          _st_source_map: JSON.stringify(embedded._st_source_map),\r\n          _st_source_file: embedded._st_source_file,\r\n          _st_source_hash: embedded._st_source_hash,\r\n        };\r\n      } else {\r\n        script.variables = {\r\n          _st_source_map: JSON.stringify(embedded._st_source_map),\r\n          _st_source_file: embedded._st_source_file,\r\n          _st_source_hash: embedded._st_source_hash,\r\n        };\r\n      }\r\n    }\r\n\r\n    return script;\r\n  }\r\n\r\n  private generateVariableInitializers(): Record<string, string> {\r\n    const vars: Record<string, string> = {};\r\n\r\n    for (const storageInfo of this.storageAnalysis.variables) {\r\n      // Only initialize transient variables\r\n      if (storageInfo.storage.type !== 'TRANSIENT') {\r\n        continue;\r\n      }\r\n\r\n      const varDecl = this.ast.variables.find(v => v.name === storageInfo.name);\r\n      if (!varDecl?.initialValue) {\r\n        continue;\r\n      }\r\n\r\n      if (varDecl.initialValue.type === 'Literal') {\r\n        // Convert literal to string representation\r\n        if (varDecl.initialValue.kind === 'string') {\r\n          vars[storageInfo.name] = String(varDecl.initialValue.value);\r\n        } else if (varDecl.initialValue.kind === 'boolean') {\r\n          vars[storageInfo.name] = varDecl.initialValue.value ? 'true' : 'false';\r\n        } else {\r\n          vars[storageInfo.name] = String(varDecl.initialValue.value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return vars;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Convenience Function\r\n// ============================================================================\r\n\r\n/**\r\n * Transpile an ST program to HA automation and script\r\n */\r\nexport function transpile(ast: ProgramNode, projectName?: string, sourceContent?: string): TranspilerResult {\r\n  const transpiler = new Transpiler(ast, projectName, sourceContent);\r\n  return transpiler.transpile();\r\n}\r\n","/**\r\n * Home Assistant WebSocket API Wrapper\r\n */\r\n\r\nimport type {\r\n  HAConnection,\r\n  HAState,\r\n  HAAutomationConfig,\r\n  HAScriptConfig,\r\n} from \"./types\";\r\n\r\n// ============================================================================\r\n// API Wrapper Class\r\n// ============================================================================\r\n\r\nexport class HAApiClient {\r\n  private readonly connection: HAConnection;\r\n\r\n  constructor(connection: HAConnection) {\r\n    this.connection = connection;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Automation API\r\n  // ==========================================================================\r\n\r\n  async getAutomations(): Promise<HAAutomationConfig[]> {\r\n    return this.connection.sendMessagePromise({\r\n      type: \"config/automation/list\",\r\n    });\r\n  }\r\n\r\n  async getAutomation(\r\n    automationId: string,\r\n  ): Promise<HAAutomationConfig | null> {\r\n    try {\r\n      return await this.connection.sendMessagePromise({\r\n        type: \"config/automation/config\",\r\n        automation_id: automationId,\r\n      });\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async saveAutomation(\r\n    automationId: string,\r\n    config: HAAutomationConfig,\r\n  ): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"config/automation/config\",\r\n      automation_id: automationId,\r\n      config,\r\n    });\r\n  }\r\n\r\n  async deleteAutomation(automationId: string): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"config/automation/delete\",\r\n      automation_id: automationId,\r\n    });\r\n  }\r\n\r\n  async reloadAutomations(): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"call_service\",\r\n      domain: \"automation\",\r\n      service: \"reload\",\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Script API\r\n  // ==========================================================================\r\n\r\n  async getScripts(): Promise<Record<string, HAScriptConfig>> {\r\n    return this.connection.sendMessagePromise({\r\n      type: \"config/script/list\",\r\n    });\r\n  }\r\n\r\n  async getScript(scriptId: string): Promise<HAScriptConfig | null> {\r\n    try {\r\n      return await this.connection.sendMessagePromise({\r\n        type: \"config/script/config\",\r\n        script_id: scriptId,\r\n      });\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async saveScript(scriptId: string, config: HAScriptConfig): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"config/script/config\",\r\n      script_id: scriptId,\r\n      config,\r\n    });\r\n  }\r\n\r\n  async deleteScript(scriptId: string): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"config/script/delete\",\r\n      script_id: scriptId,\r\n    });\r\n  }\r\n\r\n  async reloadScripts(): Promise<void> {\r\n    await this.connection.sendMessagePromise({\r\n      type: \"call_service\",\r\n      domain: \"script\",\r\n      service: \"reload\",\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Helper API\r\n  // ==========================================================================\r\n\r\n  async getStates(): Promise<HAState[]> {\r\n    // Use WebSocket call to get all states\r\n    return this.connection.sendMessagePromise({\r\n      type: \"get_states\",\r\n    });\r\n  }\r\n\r\n  async getSTHelpers(prefix: string = \"st_\"): Promise<HAState[]> {\r\n    const states = await this.getStates();\r\n    return states.filter((s) => {\r\n      const name = s.entity_id.split(\".\")[1];\r\n      return name?.startsWith(prefix);\r\n    });\r\n  }\r\n\r\n  async deleteHelper(entityId: string): Promise<void> {\r\n    const [domain, name] = entityId.split(\".\");\r\n    await this.connection.sendMessagePromise({\r\n      type: `${domain}/delete`,\r\n      // e.g. input_number_id, input_boolean_id, ...\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      [`${domain}_id`]: name as any,\r\n    });\r\n  }\r\n\r\n  async setHelperValue(entityId: string, value: unknown): Promise<void> {\r\n    const [domain] = entityId.split(\".\");\r\n\r\n    switch (domain) {\r\n      case \"input_boolean\":\r\n        await this.connection.sendMessagePromise({\r\n          type: \"call_service\",\r\n          domain: \"input_boolean\",\r\n          service: value ? \"turn_on\" : \"turn_off\",\r\n          service_data: { entity_id: entityId },\r\n        });\r\n        break;\r\n\r\n      case \"input_number\":\r\n        await this.connection.sendMessagePromise({\r\n          type: \"call_service\",\r\n          domain: \"input_number\",\r\n          service: \"set_value\",\r\n          service_data: { entity_id: entityId, value: value as number },\r\n        });\r\n        break;\r\n\r\n      case \"input_text\":\r\n        await this.connection.sendMessagePromise({\r\n          type: \"call_service\",\r\n          domain: \"input_text\",\r\n          service: \"set_value\",\r\n          service_data: { entity_id: entityId, value: value as string },\r\n        });\r\n        break;\r\n\r\n      case \"input_datetime\":\r\n        await this.connection.sendMessagePromise({\r\n          type: \"call_service\",\r\n          domain: \"input_datetime\",\r\n          service: \"set_datetime\",\r\n          service_data: { entity_id: entityId, datetime: value as string },\r\n        });\r\n        break;\r\n\r\n      case \"counter\":\r\n        await this.connection.sendMessagePromise({\r\n          type: \"call_service\",\r\n          domain: \"counter\",\r\n          service: \"set_value\",\r\n          service_data: { entity_id: entityId, value: value as number },\r\n        });\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Helper Manager - Sync ST helpers with Home Assistant\r\n */\r\n\r\nimport type { HelperConfig } from '../analyzer/types';\r\nimport type { HelperSyncResult, ExistingHelper, HAState } from './types';\r\nimport { HAApiClient } from './ha-api';\r\n\r\nexport class HelperManager {\r\n  private readonly api: HAApiClient;\r\n  private readonly projectPrefix: string;\r\n\r\n  constructor(api: HAApiClient, projectPrefix: string = 'st_') {\r\n    this.api = api;\r\n    this.projectPrefix = projectPrefix;\r\n  }\r\n\r\n  async calculateSync(required: HelperConfig[]): Promise<HelperSyncResult> {\r\n    const existing = await this.getExistingHelpers();\r\n    const existingIds = new Set(existing.map((h) => h.entityId));\r\n    const requiredIds = new Set(required.map((h) => h.id));\r\n\r\n    const result: HelperSyncResult = {\r\n      toCreate: [],\r\n      toUpdate: [],\r\n      toDelete: [],\r\n      unchanged: [],\r\n    };\r\n\r\n    for (const helper of required) {\r\n      if (!existingIds.has(helper.id)) {\r\n        result.toCreate.push(helper);\r\n      } else {\r\n        const existingHelper = existing.find((h) => h.entityId === helper.id);\r\n        if (existingHelper && this.needsUpdate(helper, existingHelper)) {\r\n          result.toUpdate.push(helper);\r\n        } else {\r\n          result.unchanged.push(helper.id);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const helper of existing) {\r\n      if (!requiredIds.has(helper.entityId)) {\r\n        result.toDelete.push(helper.entityId);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getExistingHelpers(): Promise<ExistingHelper[]> {\r\n    const states = await this.api.getSTHelpers(this.projectPrefix);\r\n\r\n    return states.map((s) => ({\r\n      entityId: s.entity_id,\r\n      type: s.entity_id.split('.')[0],\r\n      state: s.state,\r\n      attributes: s.attributes,\r\n    }));\r\n  }\r\n\r\n  private needsUpdate(required: HelperConfig, existing: ExistingHelper): boolean {\r\n    if (required.type !== existing.type) {\r\n      return true;\r\n    }\r\n\r\n    if (required.type === 'input_number') {\r\n      const attrs = existing.attributes;\r\n      const min = attrs.min as number | undefined;\r\n      const max = attrs.max as number | undefined;\r\n      if (required.min !== min || required.max !== max) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async applySync(\r\n    syncResult: HelperSyncResult,\r\n    options: { skipDeletes?: boolean } = {},\r\n  ): Promise<void> {\r\n    for (const helper of syncResult.toCreate) {\r\n      await this.createHelper(helper);\r\n    }\r\n\r\n    for (const helper of syncResult.toUpdate) {\r\n      await this.api.deleteHelper(helper.id);\r\n      await this.createHelper(helper);\r\n    }\r\n\r\n    if (!options.skipDeletes) {\r\n      for (const entityId of syncResult.toDelete) {\r\n        await this.api.deleteHelper(entityId);\r\n      }\r\n    }\r\n  }\r\n\r\n  async createHelper(config: HelperConfig): Promise<void> {\r\n    const name = config.name || this.extractName(config.id);\r\n\r\n    switch (config.type) {\r\n      case 'input_boolean':\r\n        await this.api.setHelperValue(config.id, config.initial ?? false);\r\n        break;\r\n\r\n      case 'input_number':\r\n        await this.api.setHelperValue(config.id, config.initial ?? config.min ?? 0);\r\n        break;\r\n\r\n      case 'input_text':\r\n        await this.api.setHelperValue(config.id, config.initial ?? '');\r\n        break;\r\n\r\n      case 'input_datetime':\r\n        await this.api.setHelperValue(config.id, config.initial ?? '');\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unknown helper type: ${config.type} (${name})`);\r\n    }\r\n  }\r\n\r\n  private extractName(entityId: string): string {\r\n    const parts = entityId.split('.');\r\n    if (parts.length !== 2) return entityId;\r\n\r\n    return parts[1]\r\n      .split('_')\r\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\r\n      .join(' ');\r\n  }\r\n\r\n  async getHelperStates(helperIds: string[]): Promise<Record<string, unknown>> {\r\n    const states = await this.api.getStates();\r\n    const result: Record<string, unknown> = {};\r\n\r\n    for (const id of helperIds) {\r\n      const state = states.find((s) => s.entity_id === id);\r\n      if (state) {\r\n        result[id] = this.parseHelperValue(state);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private parseHelperValue(state: HAState): unknown {\r\n    const domain = state.entity_id.split('.')[0];\r\n\r\n    switch (domain) {\r\n      case 'input_boolean':\r\n        return state.state === 'on';\r\n\r\n      case 'input_number':\r\n      case 'counter':\r\n        return Number.isNaN(Number(state.state)) ? 0 : Number(state.state);\r\n\r\n      case 'input_text':\r\n      case 'input_datetime':\r\n      default:\r\n        return state.state;\r\n    }\r\n  }\r\n\r\n  async restoreHelperStates(states: Record<string, unknown>): Promise<void> {\r\n    for (const [entityId, value] of Object.entries(states)) {\r\n      try {\r\n        await this.api.setHelperValue(entityId, value);\r\n      } catch (error) {\r\n        // eslint-disable-next-line no-console\r\n        console.warn(`Failed to restore ${entityId}:`, error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n","/**\r\n * Backup Manager - Save and restore deployment state\r\n */\r\n\r\nimport type { Backup } from './types';\r\nimport type { HelperConfig } from '../analyzer/types';\r\nimport { HAApiClient } from './ha-api';\r\nimport { HelperManager } from './helper-manager';\r\n\r\nconst BACKUP_STORAGE_KEY = 'st_hass_backups';\r\nconst MAX_BACKUPS = 10;\r\n\r\nexport class BackupManager {\r\n  private readonly api: HAApiClient;\r\n  private readonly helperManager: HelperManager;\r\n\r\n  constructor(api: HAApiClient) {\r\n    this.api = api;\r\n    this.helperManager = new HelperManager(api);\r\n  }\r\n\r\n  async createBackup(automationId: string, programName: string): Promise<Backup> {\r\n    const automation = await this.api.getAutomation(automationId);\r\n\r\n    const scriptId = `st_${automationId}_logic`;\r\n    const script = await this.api.getScript(scriptId);\r\n\r\n    const helpers = await this.helperManager.getExistingHelpers();\r\n    const helperConfigs: HelperConfig[] = helpers.map((h) => ({\r\n      id: h.entityId,\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      type: h.type as any,\r\n      name: (h.attributes.friendly_name as string) || h.entityId,\r\n    }));\r\n\r\n    const helperIds = helperConfigs.map((h) => h.id);\r\n    const helperStates = await this.helperManager.getHelperStates(helperIds);\r\n\r\n    const backup: Backup = {\r\n      id: this.generateId(),\r\n      timestamp: new Date(),\r\n      projectName: 'default',\r\n      programName,\r\n      data: {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        automation: automation as any,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        script: script as any,\r\n        helpers: helperConfigs,\r\n        helperStates,\r\n      },\r\n    };\r\n\r\n    await this.saveBackup(backup);\r\n\r\n    return backup;\r\n  }\r\n\r\n  async restoreBackup(backupId: string): Promise<void> {\r\n    const backup = await this.loadBackup(backupId);\r\n    if (!backup) {\r\n      throw new Error(`Backup not found: ${backupId}`);\r\n    }\r\n\r\n    if (backup.data.automation) {\r\n      await this.api.saveAutomation(\r\n        backup.data.automation.id,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        backup.data.automation as any,\r\n      );\r\n    }\r\n\r\n    if (backup.data.script && backup.data.automation) {\r\n      const scriptId = `st_${backup.data.automation.id}_logic`;\r\n      await this.api.saveScript(\r\n        scriptId,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        backup.data.script as any,\r\n      );\r\n    }\r\n\r\n    for (const helper of backup.data.helpers) {\r\n      try {\r\n        await this.helperManager.createHelper(helper);\r\n      } catch {\r\n        // Helper might already exist\r\n      }\r\n    }\r\n\r\n    await this.helperManager.restoreHelperStates(backup.data.helperStates);\r\n\r\n    await this.api.reloadAutomations();\r\n    await this.api.reloadScripts();\r\n  }\r\n\r\n  async listBackups(): Promise<Backup[]> {\r\n    const stored = window.localStorage.getItem(BACKUP_STORAGE_KEY);\r\n    if (!stored) return [];\r\n\r\n    try {\r\n      const backups = JSON.parse(stored) as Backup[];\r\n      return backups.map((b) => ({\r\n        ...b,\r\n        timestamp: new Date(b.timestamp),\r\n      }));\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async loadBackup(backupId: string): Promise<Backup | null> {\r\n    const backups = await this.listBackups();\r\n    return backups.find((b) => b.id === backupId) || null;\r\n  }\r\n\r\n  async deleteBackup(backupId: string): Promise<void> {\r\n    const backups = await this.listBackups();\r\n    const filtered = backups.filter((b) => b.id !== backupId);\r\n    window.localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(filtered));\r\n  }\r\n\r\n  private async saveBackup(backup: Backup): Promise<void> {\r\n    const backups = await this.listBackups();\r\n\r\n    backups.unshift(backup);\r\n\r\n    const trimmed = backups.slice(0, MAX_BACKUPS);\r\n\r\n    window.localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(trimmed));\r\n  }\r\n\r\n  async cleanupOldBackups(keepCount: number = MAX_BACKUPS): Promise<number> {\r\n    const backups = await this.listBackups();\r\n\r\n    if (backups.length <= keepCount) return 0;\r\n\r\n    const toDelete = backups.slice(keepCount);\r\n    const remaining = backups.slice(0, keepCount);\r\n\r\n    window.localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(remaining));\r\n\r\n    return toDelete.length;\r\n  }\r\n\r\n  private generateId(): string {\r\n    return `backup_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`;\r\n  }\r\n}\r\n\r\n","/**\r\n * Migration Handler\r\n *\r\n * Handles schema changes between deployments with optional user interaction.\r\n */\r\n\r\nimport type {\r\n  VariableSchema,\r\n  ProgramSchema,\r\n  MigrationIssue,\r\n  MigrationOption,\r\n  MigrationPlan,\r\n  MigrationResolution,\r\n  MigrationResult,\r\n  StoredSchemas,\r\n} from \"./migration-types\";\r\n\r\n// ============================================================================\r\n// Schema Storage\r\n// ============================================================================\r\n\r\nconst SCHEMA_STORAGE_KEY = \"st_hass_schemas\";\r\n\r\nexport class SchemaStorage {\r\n  save(programId: string, schema: ProgramSchema): void {\r\n    const stored = this.loadAll();\r\n    stored[programId] = schema;\r\n    // localStorage is available in HA panel (browser) context\r\n    localStorage.setItem(SCHEMA_STORAGE_KEY, JSON.stringify(stored));\r\n  }\r\n\r\n  load(programId: string): ProgramSchema | null {\r\n    const stored = this.loadAll();\r\n    return stored[programId] || null;\r\n  }\r\n\r\n  loadAll(): StoredSchemas {\r\n    const raw = localStorage.getItem(SCHEMA_STORAGE_KEY);\r\n    if (!raw) return {};\r\n    try {\r\n      return JSON.parse(raw) as StoredSchemas;\r\n    } catch {\r\n      return {};\r\n    }\r\n  }\r\n\r\n  delete(programId: string): void {\r\n    const stored = this.loadAll();\r\n    delete stored[programId];\r\n    localStorage.setItem(SCHEMA_STORAGE_KEY, JSON.stringify(stored));\r\n  }\r\n\r\n  clear(): void {\r\n    localStorage.removeItem(SCHEMA_STORAGE_KEY);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Migration Detector\r\n// ============================================================================\r\n\r\nexport class MigrationDetector {\r\n  /**\r\n   * Detect migration issues between old and new schema\r\n   */\r\n  detectIssues(\r\n    oldSchema: ProgramSchema | null,\r\n    newSchema: ProgramSchema,\r\n  ): MigrationPlan {\r\n    const issues: MigrationIssue[] = [];\r\n\r\n    if (!oldSchema) {\r\n      // First deployment, no migration needed\r\n      return {\r\n        issues: [],\r\n        hasDestructiveChanges: false,\r\n        requiresUserInput: false,\r\n      };\r\n    }\r\n\r\n    const oldVars = new Map(oldSchema.variables.map((v) => [v.name, v]));\r\n    const newVars = new Map(newSchema.variables.map((v) => [v.name, v]));\r\n\r\n    // Check for removed variables\r\n    for (const [name, oldVar] of oldVars) {\r\n      if (!newVars.has(name)) {\r\n        issues.push(this.createRemovedIssue(oldVar));\r\n      }\r\n    }\r\n\r\n    // Check for added and changed variables\r\n    for (const [name, newVar] of newVars) {\r\n      const oldVar = oldVars.get(name);\r\n\r\n      if (!oldVar) {\r\n        issues.push(this.createAddedIssue(newVar));\r\n      } else {\r\n        // Check for changes\r\n        const changeIssues = this.detectChanges(oldVar, newVar);\r\n        issues.push(...changeIssues);\r\n      }\r\n    }\r\n\r\n    return {\r\n      issues,\r\n      hasDestructiveChanges: issues.some((i) =>\r\n        i.options.some((o) => o.isDestructive),\r\n      ),\r\n      requiresUserInput: issues.some(\r\n        (i) => i.type === \"removed\" || i.type === \"type_changed\",\r\n      ),\r\n    };\r\n  }\r\n\r\n  private createRemovedIssue(oldVar: VariableSchema): MigrationIssue {\r\n    return {\r\n      type: \"removed\",\r\n      variable: oldVar.name,\r\n      helperId: oldVar.helperId,\r\n      details: `Variable '${oldVar.name}' wurde aus dem Code entfernt`,\r\n      oldSchema: oldVar,\r\n      options: [\r\n        {\r\n          id: \"delete\",\r\n          label: \"Helper löschen\",\r\n          description: \"Entfernt den Helper und seinen Wert\",\r\n          isDestructive: true,\r\n        },\r\n        {\r\n          id: \"keep\",\r\n          label: \"Helper behalten (orphaned)\",\r\n          description: \"Behält den Helper, wird aber nicht mehr verwendet\",\r\n        },\r\n      ],\r\n      defaultOption: \"delete\",\r\n    };\r\n  }\r\n\r\n  private createAddedIssue(newVar: VariableSchema): MigrationIssue {\r\n    return {\r\n      type: \"added\",\r\n      variable: newVar.name,\r\n      helperId: newVar.helperId,\r\n      details: `Neue Variable '${newVar.name}' hinzugefügt`,\r\n      newSchema: newVar,\r\n      options: [\r\n        {\r\n          id: \"create\",\r\n          label: \"Helper erstellen\",\r\n          description: `Erstellt neuen Helper mit Initialwert ${JSON.stringify(\r\n            newVar.initialValue,\r\n          )}`,\r\n        },\r\n      ],\r\n      defaultOption: \"create\",\r\n    };\r\n  }\r\n\r\n  private detectChanges(\r\n    oldVar: VariableSchema,\r\n    newVar: VariableSchema,\r\n  ): MigrationIssue[] {\r\n    const issues: MigrationIssue[] = [];\r\n\r\n    // Type change\r\n    if (oldVar.dataType !== newVar.dataType) {\r\n      issues.push({\r\n        type: \"type_changed\",\r\n        variable: oldVar.name,\r\n        helperId: oldVar.helperId,\r\n        details: `Typ geändert: ${oldVar.dataType} → ${newVar.dataType}`,\r\n        oldSchema: oldVar,\r\n        newSchema: newVar,\r\n        options: this.getTypeChangeOptions(oldVar, newVar),\r\n        defaultOption: \"convert\",\r\n      });\r\n    }\r\n\r\n    // Range change (for numbers)\r\n    if (\r\n      oldVar.helperType === \"input_number\" &&\r\n      newVar.helperType === \"input_number\"\r\n    ) {\r\n      if (oldVar.min !== newVar.min || oldVar.max !== newVar.max) {\r\n        issues.push({\r\n          type: \"range_changed\",\r\n          variable: oldVar.name,\r\n          helperId: oldVar.helperId,\r\n          details: `Bereich geändert: [${oldVar.min}, ${oldVar.max}] → [${newVar.min}, ${newVar.max}]`,\r\n          oldSchema: oldVar,\r\n          newSchema: newVar,\r\n          options: [\r\n            {\r\n              id: \"update_range\",\r\n              label: \"Bereich aktualisieren\",\r\n              description:\r\n                \"Aktualisiert min/max, Wert wird ggf. begrenzt\",\r\n            },\r\n            {\r\n              id: \"reset\",\r\n              label: \"Auf Initialwert zurücksetzen\",\r\n              description: `Setzt auf ${newVar.initialValue}`,\r\n            },\r\n          ],\r\n          defaultOption: \"update_range\",\r\n        });\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  private getTypeChangeOptions(\r\n    oldVar: VariableSchema,\r\n    newVar: VariableSchema,\r\n  ): MigrationOption[] {\r\n    const options: MigrationOption[] = [];\r\n\r\n    // Check if conversion is possible\r\n    if (this.canConvert(oldVar.dataType, newVar.dataType)) {\r\n      options.push({\r\n        id: \"convert\",\r\n        label: \"Wert konvertieren\",\r\n        description: `Konvertiert ${oldVar.dataType} zu ${newVar.dataType}`,\r\n      });\r\n    }\r\n\r\n    options.push({\r\n      id: \"reset\",\r\n      label: \"Auf Initialwert zurücksetzen\",\r\n      description: `Setzt auf ${JSON.stringify(newVar.initialValue)}`,\r\n      isDestructive: true,\r\n    });\r\n\r\n    options.push({\r\n      id: \"keep_helper\",\r\n      label: \"Alten Helper behalten, neuen erstellen\",\r\n      description: \"Erstellt neuen Helper, alter wird orphaned\",\r\n    });\r\n\r\n    return options;\r\n  }\r\n\r\n  private canConvert(fromType: string, toType: string): boolean {\r\n    const conversions: Record<string, string[]> = {\r\n      INT: [\"DINT\", \"REAL\", \"LREAL\", \"STRING\"],\r\n      DINT: [\"REAL\", \"LREAL\", \"STRING\"],\r\n      REAL: [\"LREAL\", \"STRING\"],\r\n      LREAL: [\"STRING\"],\r\n      BOOL: [\"INT\", \"STRING\"],\r\n    };\r\n\r\n    return conversions[fromType]?.includes(toType) ?? false;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Migration Executor\r\n// ============================================================================\r\n\r\nexport class MigrationExecutor {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  private haApi: any;\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  constructor(haApi: any) {\r\n    this.haApi = haApi;\r\n  }\r\n\r\n  /**\r\n   * Execute migration with user-provided resolutions\r\n   */\r\n  async execute(\r\n    plan: MigrationPlan,\r\n    resolutions: MigrationResolution[],\r\n  ): Promise<MigrationResult> {\r\n    const result: MigrationResult = {\r\n      success: true,\r\n      appliedChanges: [],\r\n      errors: [],\r\n    };\r\n\r\n    // Create resolution map\r\n    const resolutionMap = new Map(\r\n      resolutions.map((r) => [r.issueId, r.selectedOption]),\r\n    );\r\n\r\n    for (const issue of plan.issues) {\r\n      const selectedOption =\r\n        resolutionMap.get(issue.variable) ?? issue.defaultOption;\r\n\r\n      try {\r\n        await this.applyResolution(issue, selectedOption);\r\n        result.appliedChanges.push(`${issue.variable}: ${selectedOption}`);\r\n      } catch (error) {\r\n        result.success = false;\r\n        result.errors.push(\r\n          `${issue.variable}: ${\r\n            error instanceof Error ? error.message : String(error)\r\n          }`,\r\n        );\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private async applyResolution(\r\n    issue: MigrationIssue,\r\n    option: string,\r\n  ): Promise<void> {\r\n    switch (issue.type) {\r\n      case \"added\":\r\n        if (option === \"create\") {\r\n          await this.createHelper(issue.newSchema!);\r\n        }\r\n        break;\r\n\r\n      case \"removed\":\r\n        if (option === \"delete\") {\r\n          await this.deleteHelper(issue.helperId);\r\n        }\r\n        // 'keep' does nothing\r\n        break;\r\n\r\n      case \"type_changed\":\r\n        await this.handleTypeChange(issue, option);\r\n        break;\r\n\r\n      case \"range_changed\":\r\n        await this.handleRangeChange(issue, option);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async handleTypeChange(\r\n    issue: MigrationIssue,\r\n    option: string,\r\n  ): Promise<void> {\r\n    switch (option) {\r\n      case \"convert\": {\r\n        const currentValue = await this.getHelperValue(issue.helperId);\r\n        const convertedValue = this.convertValue(\r\n          currentValue,\r\n          issue.oldSchema!.dataType,\r\n          issue.newSchema!.dataType,\r\n        );\r\n        await this.deleteHelper(issue.helperId);\r\n        await this.createHelper(issue.newSchema!, convertedValue);\r\n        break;\r\n      }\r\n\r\n      case \"reset\":\r\n        await this.deleteHelper(issue.helperId);\r\n        await this.createHelper(issue.newSchema!);\r\n        break;\r\n\r\n      case \"keep_helper\": {\r\n        // Create new helper with different ID\r\n        const newHelperId = `${issue.newSchema!.helperId}_v2`;\r\n        await this.createHelper({\r\n          ...issue.newSchema!,\r\n          helperId: newHelperId,\r\n        });\r\n        break;\r\n      }\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async handleRangeChange(\r\n    issue: MigrationIssue,\r\n    option: string,\r\n  ): Promise<void> {\r\n    if (option === \"update_range\") {\r\n      const currentValue = await this.getHelperValue(issue.helperId);\r\n      const clampedValue = Math.max(\r\n        issue.newSchema!.min ?? Number.MIN_SAFE_INTEGER,\r\n        Math.min(issue.newSchema!.max ?? Number.MAX_SAFE_INTEGER, Number(currentValue)),\r\n      );\r\n\r\n      await this.deleteHelper(issue.helperId);\r\n      await this.createHelper(issue.newSchema!, clampedValue);\r\n    } else if (option === \"reset\") {\r\n      await this.deleteHelper(issue.helperId);\r\n      await this.createHelper(issue.newSchema!);\r\n    }\r\n  }\r\n\r\n  private convertValue(value: unknown, _fromType: string, toType: string): unknown {\r\n    switch (toType) {\r\n      case \"INT\":\r\n      case \"DINT\":\r\n        return Math.round(Number(value));\r\n      case \"REAL\":\r\n      case \"LREAL\":\r\n        return Number(value);\r\n      case \"STRING\":\r\n        return String(value);\r\n      case \"BOOL\":\r\n        return Boolean(value);\r\n      default:\r\n        return value;\r\n    }\r\n  }\r\n\r\n  private async createHelper(schema: VariableSchema, value?: unknown): Promise<void> {\r\n    const initialValue = value ?? schema.initialValue;\r\n\r\n    switch (schema.helperType) {\r\n      case \"input_boolean\":\r\n        await this.haApi.createInputBoolean?.({\r\n          name: this.extractHelperName(schema.helperId),\r\n          initial: Boolean(initialValue),\r\n        });\r\n        break;\r\n\r\n      case \"input_number\":\r\n        await this.haApi.createInputNumber?.({\r\n          name: this.extractHelperName(schema.helperId),\r\n          initial: Number(initialValue),\r\n          min: schema.min,\r\n          max: schema.max,\r\n          step: schema.step,\r\n          mode: \"box\",\r\n        });\r\n        break;\r\n\r\n      case \"input_text\":\r\n        await this.haApi.createInputText?.({\r\n          name: this.extractHelperName(schema.helperId),\r\n          initial: String(initialValue),\r\n        });\r\n        break;\r\n\r\n      case \"input_datetime\":\r\n        await this.haApi.createInputDateTime?.({\r\n          name: this.extractHelperName(schema.helperId),\r\n          initial: String(initialValue),\r\n        });\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async deleteHelper(helperId: string): Promise<void> {\r\n    await this.haApi.deleteHelper?.(helperId);\r\n  }\r\n\r\n  private async getHelperValue(helperId: string): Promise<unknown> {\r\n    return this.haApi.getState\r\n      ? this.haApi.getState(helperId)\r\n      : this.haApi.getHelperValue?.(helperId);\r\n  }\r\n\r\n  private extractHelperName(helperId: string): string {\r\n    // input_number.st_prog_var → ST Prog Var\r\n    const parts = helperId.split(\".\");\r\n    if (parts.length > 1) {\r\n      return parts[1]\r\n        .replace(/^st_/, \"ST \")\r\n        .replace(/_/g, \" \")\r\n        .replace(/\\b\\w/g, (c: string) => c.toUpperCase());\r\n    }\r\n    return helperId;\r\n  }\r\n}\r\n\r\n","/**\r\n * Deploy Manager - Transactional deployment with rollback\r\n */\r\n\r\nimport type { TranspilerResult } from '../transpiler/types';\r\nimport type { HelperConfig } from '../analyzer/types';\r\nimport type {\r\n  DeployTransaction,\r\n  DeployOperation,\r\n  DeployResult,\r\n  DeployError,\r\n} from './types';\r\nimport { HAApiClient } from './ha-api';\r\nimport { HelperManager } from './helper-manager';\r\nimport { BackupManager } from './backup-manager';\r\nimport {\r\n  SchemaStorage,\r\n  MigrationDetector,\r\n} from '../restore/migration-handler';\r\nimport type { ProgramSchema, VariableSchema, MigrationPlan } from '../restore/migration-types';\r\n\r\nexport class DeployManager {\r\n  private readonly api: HAApiClient;\r\n  private readonly helperManager: HelperManager;\r\n  private readonly backupManager: BackupManager;\r\n  private readonly schemaStorage: SchemaStorage;\r\n  private readonly migrationDetector: MigrationDetector;\r\n\r\n  constructor(api: HAApiClient) {\r\n    this.api = api;\r\n    this.helperManager = new HelperManager(api);\r\n    this.backupManager = new BackupManager(api);\r\n    this.schemaStorage = new SchemaStorage();\r\n    this.migrationDetector = new MigrationDetector();\r\n  }\r\n\r\n  async deploy(\r\n    result: TranspilerResult,\r\n    options: {\r\n      createBackup?: boolean;\r\n      dryRun?: boolean;\r\n    } = {},\r\n  ): Promise<DeployResult> {\r\n    const transaction = this.createTransaction(result);\r\n\r\n    try {\r\n      await this.validateDeployment(result);\r\n\r\n      if (options.createBackup) {\r\n        await this.backupManager.createBackup(result.automation.id, result.automation.alias);\r\n      }\r\n\r\n      const operations = await this.calculateOperations(result);\r\n      transaction.operations = operations;\r\n\r\n      if (options.dryRun) {\r\n        return {\r\n          success: true,\r\n          transactionId: transaction.id,\r\n          operations,\r\n          errors: [],\r\n        };\r\n      }\r\n\r\n      transaction.status = 'in_progress';\r\n\r\n      for (const op of operations) {\r\n        try {\r\n          await this.applyOperation(op);\r\n          op.status = 'applied';\r\n        } catch (error) {\r\n          op.status = 'failed';\r\n          op.error = error instanceof Error ? error.message : String(error);\r\n\r\n          await this.rollback(transaction);\r\n\r\n          return {\r\n            success: false,\r\n            transactionId: transaction.id,\r\n            operations,\r\n            errors: [\r\n              {\r\n                operation: op,\r\n                message: op.error ?? 'Unknown deploy error',\r\n                code: 'DEPLOY_FAILED',\r\n              },\r\n            ],\r\n          };\r\n        }\r\n      }\r\n\r\n      await this.reloadAll();\r\n\r\n      const verified = await this.verifyDeployment(result);\r\n      if (!verified) {\r\n        await this.rollback(transaction);\r\n\r\n        return {\r\n          success: false,\r\n          transactionId: transaction.id,\r\n          operations,\r\n          errors: [\r\n            {\r\n              message: 'Deployment verification failed',\r\n              code: 'VERIFY_FAILED',\r\n            },\r\n          ],\r\n        };\r\n      }\r\n\r\n      transaction.status = 'committed';\r\n\r\n      return {\r\n        success: true,\r\n        transactionId: transaction.id,\r\n        operations,\r\n        errors: [],\r\n      };\r\n    } catch (error) {\r\n      transaction.status = 'failed';\r\n\r\n      const deployError: DeployError = {\r\n        message: error instanceof Error ? error.message : String(error),\r\n        code: 'DEPLOY_ERROR',\r\n      };\r\n\r\n      return {\r\n        success: false,\r\n        transactionId: transaction.id,\r\n        operations: transaction.operations,\r\n        errors: [deployError],\r\n      };\r\n    }\r\n  }\r\n\r\n  async rollback(transaction: DeployTransaction): Promise<void> {\r\n    const appliedOps = transaction.operations.filter((op) => op.status === 'applied').reverse();\r\n\r\n    for (const op of appliedOps) {\r\n      try {\r\n        await this.revertOperation(op);\r\n        op.status = 'reverted';\r\n      } catch (error) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(`Failed to revert operation ${op.id}:`, error);\r\n      }\r\n    }\r\n\r\n    transaction.status = 'rolled_back';\r\n  }\r\n\r\n  private createTransaction(result: TranspilerResult): DeployTransaction {\r\n    return {\r\n      id: this.generateId(),\r\n      timestamp: new Date(),\r\n      projectName: 'default',\r\n      programName: result.automation.alias.replace('[ST] ', ''),\r\n      operations: [],\r\n      status: 'pending',\r\n    };\r\n  }\r\n\r\n  private async validateDeployment(result: TranspilerResult): Promise<void> {\r\n    const errors = result.diagnostics.filter((d) => d.severity === 'Error');\r\n    if (errors.length > 0) {\r\n      throw new Error(`Transpilation errors: ${errors.map((e) => e.message).join(', ')}`);\r\n    }\r\n\r\n    if (result.automation.trigger.length === 0) {\r\n      throw new Error('Automation has no triggers - it will never execute');\r\n    }\r\n  }\r\n\r\n  private async calculateOperations(result: TranspilerResult): Promise<DeployOperation[]> {\r\n    const operations: DeployOperation[] = [];\r\n\r\n    const existingAutomation = await this.api.getAutomation(result.automation.id);\r\n    operations.push({\r\n      id: this.generateId(),\r\n      type: existingAutomation ? 'update' : 'create',\r\n      entityType: 'automation',\r\n      entityId: result.automation.id,\r\n      previousState: existingAutomation ?? undefined,\r\n      newState: result.automation,\r\n      status: 'pending',\r\n    });\r\n\r\n    const scriptId = `st_${result.automation.id}_logic`;\r\n    const existingScript = await this.api.getScript(scriptId);\r\n    operations.push({\r\n      id: this.generateId(),\r\n      type: existingScript ? 'update' : 'create',\r\n      entityType: 'script',\r\n      entityId: scriptId,\r\n      previousState: existingScript ?? undefined,\r\n      newState: result.script,\r\n      status: 'pending',\r\n    });\r\n\r\n    const helperSync = await this.helperManager.calculateSync(result.helpers);\r\n\r\n    for (const helper of helperSync.toCreate) {\r\n      operations.push({\r\n        id: this.generateId(),\r\n        type: 'create',\r\n        entityType: 'helper',\r\n        entityId: helper.id,\r\n        newState: helper,\r\n        status: 'pending',\r\n      });\r\n    }\r\n\r\n    for (const helper of helperSync.toUpdate) {\r\n      operations.push({\r\n        id: this.generateId(),\r\n        type: 'update',\r\n        entityType: 'helper',\r\n        entityId: helper.id,\r\n        newState: helper,\r\n        status: 'pending',\r\n      });\r\n    }\r\n\r\n    for (const helperId of helperSync.toDelete) {\r\n      operations.push({\r\n        id: this.generateId(),\r\n        type: 'delete',\r\n        entityType: 'helper',\r\n        entityId: helperId,\r\n        status: 'pending',\r\n      });\r\n    }\r\n\r\n    return operations;\r\n  }\r\n\r\n  /**\r\n   * Build a ProgramSchema from current helper configuration.\r\n   * This does not change deploy behaviour and can be used by UI code\r\n   * to drive migration flows.\r\n   */\r\n  public buildProgramSchema(result: TranspilerResult): ProgramSchema {\r\n    const programName = result.automation.alias.replace('[ST] ', '');\r\n    const projectName = 'default';\r\n\r\n    const variables: VariableSchema[] = result.helpers.map((helper) => ({\r\n      name: helper.id,\r\n      dataType: helper.type,\r\n      helperId: helper.id,\r\n      helperType: helper.type === 'counter' ? 'input_number' : (helper.type as VariableSchema['helperType']),\r\n      initialValue: helper.initial,\r\n      restorePolicy: 0 as never, // restore policy is assigned at analysis time; not wired here yet\r\n      min: helper.min,\r\n      max: helper.max,\r\n      step: helper.step,\r\n    }));\r\n\r\n    return {\r\n      programName,\r\n      projectName,\r\n      variables,\r\n      version: '1.0',\r\n      generatedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a migration plan based on previous and current schemas.\r\n   * Intended to be called by higher-level UI logic before executing a deploy.\r\n   */\r\n  public createMigrationPlan(result: TranspilerResult): MigrationPlan {\r\n    const schema = this.buildProgramSchema(result);\r\n    const programId = result.automation.id;\r\n    const previous = this.schemaStorage.load(programId);\r\n    const plan = this.migrationDetector.detectIssues(previous, schema);\r\n    this.schemaStorage.save(programId, schema);\r\n    return plan;\r\n  }\r\n\r\n  private generateId(): string {\r\n    return `op_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`;\r\n  }\r\n\r\n  private async applyOperation(op: DeployOperation): Promise<void> {\r\n    switch (op.entityType) {\r\n      case 'automation':\r\n        if (op.type === 'delete') {\r\n          await this.api.deleteAutomation(op.entityId);\r\n        } else {\r\n          await this.api.saveAutomation(op.entityId, op.newState as never);\r\n        }\r\n        break;\r\n\r\n      case 'script':\r\n        if (op.type === 'delete') {\r\n          await this.api.deleteScript(op.entityId);\r\n        } else {\r\n          await this.api.saveScript(op.entityId, op.newState as never);\r\n        }\r\n        break;\r\n\r\n      case 'helper':\r\n        if (op.type === 'delete') {\r\n          await this.api.deleteHelper(op.entityId);\r\n        } else {\r\n          await this.helperManager.createHelper(op.newState as HelperConfig);\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async revertOperation(op: DeployOperation): Promise<void> {\r\n    switch (op.type) {\r\n      case 'create':\r\n        if (op.entityType === 'automation') {\r\n          await this.api.deleteAutomation(op.entityId);\r\n        } else if (op.entityType === 'script') {\r\n          await this.api.deleteScript(op.entityId);\r\n        } else if (op.entityType === 'helper') {\r\n          await this.api.deleteHelper(op.entityId);\r\n        }\r\n        break;\r\n\r\n      case 'update':\r\n        if (!op.previousState) return;\r\n        if (op.entityType === 'automation') {\r\n          await this.api.saveAutomation(op.entityId, op.previousState as never);\r\n        } else if (op.entityType === 'script') {\r\n          await this.api.saveScript(op.entityId, op.previousState as never);\r\n        } else if (op.entityType === 'helper') {\r\n          await this.api.deleteHelper(op.entityId);\r\n          await this.helperManager.createHelper(op.previousState as HelperConfig);\r\n        }\r\n        break;\r\n\r\n      case 'delete':\r\n        if (!op.previousState) return;\r\n        if (op.entityType === 'automation') {\r\n          await this.api.saveAutomation(op.entityId, op.previousState as never);\r\n        } else if (op.entityType === 'script') {\r\n          await this.api.saveScript(op.entityId, op.previousState as never);\r\n        } else if (op.entityType === 'helper') {\r\n          await this.helperManager.createHelper(op.previousState as HelperConfig);\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async reloadAll(): Promise<void> {\r\n    await this.api.reloadAutomations();\r\n    await this.api.reloadScripts();\r\n  }\r\n\r\n  private async verifyDeployment(result: TranspilerResult): Promise<boolean> {\r\n    const automation = await this.api.getAutomation(result.automation.id);\r\n    if (!automation) return false;\r\n\r\n    const scriptId = `st_${result.automation.id}_logic`;\r\n    const script = await this.api.getScript(scriptId);\r\n    if (!script) return false;\r\n\r\n    const states = await this.api.getStates();\r\n    for (const helper of result.helpers) {\r\n      const exists = states.some((s) => s.entity_id === helper.id);\r\n      if (!exists) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport async function deploy(\r\n  api: HAApiClient,\r\n  result: TranspilerResult,\r\n  options?: { createBackup?: boolean; dryRun?: boolean },\r\n): Promise<DeployResult> {\r\n  const manager = new DeployManager(api);\r\n  return manager.deploy(result, options);\r\n}\r\n\r\n"],"names":["JinjaGenerator","context","timerResolver","__publicField","expr","lit","timeLiteral","match","hours","minutes","seconds","ms","totalSeconds","ref","varInfo","entityId","dataType","state","invalid","helperId","left","right","operand","call","funcName","args","a","selector","inputs","result","i","mn","input","mx","root","mapped","generateEntityStateRead","generateThrottleCondition","lastRunHelper","throttleSeconds","MAX_LOOP_ITERATIONS","ActionGenerator","sourceMap","statements","actions","stmt","index","stmtActions","targetName","target","current","name","value","_dataType","domain","valueExpr","options","elsif","selectorExpr","caseClause","conditions","val","valExpr","finalCondition","fromExpr","toExpr","byExpr","countExpr","loopVarInit","loopVarIncrement","safetyVar","safetyInit","safetyIncrement","condition","safetyCondition","data","arg","key","TimerTranspiler","_context","upper","instanceName","type","paramName","_a","instance","entities","helpers","mainActions","finishedAutomation","outputMappings","pulseTriggeredId","base","baseName","additionalCondition","timerId","durationSeconds","expression","s","total","TimerOutputResolver","mappings","output","varName","member","SourceMapBuilder","segment","fn","location","description","path","node","automationId","scriptId","content","hash","char","Transpiler","ast","projectName","sourceContent","analyzeDependencies","analyzeStorage","d","automation","script","variables","entityBindings","varDecl","storageInfo","v","depInfo","_b","_c","timerVars","typeName","walkAST","timerType","parsed","pragmas","parsePragmas","throttle","p","debounce","t","throttleHelper","debounceSeconds","mode","actionGenerator","initVars","bodyActions","embedded","vars","transpile","HAApiClient","connection","config","prefix","HelperManager","api","projectPrefix","required","existing","existingIds","h","requiredIds","helper","existingHelper","attrs","min","max","syncResult","parts","word","helperIds","states","id","error","BACKUP_STORAGE_KEY","MAX_BACKUPS","BackupManager","programName","helperConfigs","helperStates","backup","backupId","stored","b","filtered","backups","trimmed","keepCount","toDelete","remaining","SCHEMA_STORAGE_KEY","SchemaStorage","programId","schema","raw","MigrationDetector","oldSchema","newSchema","issues","oldVars","newVars","oldVar","newVar","changeIssues","o","fromType","toType","DeployManager","transaction","operations","op","deployError","appliedOps","errors","e","existingAutomation","existingScript","helperSync","previous","plan","deploy"],"mappings":"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"}